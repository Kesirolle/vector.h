<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Ion: Ion Users Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_users_guide.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Ion Users Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="UG_TOC"></a>
Table of Contents</h1>
<ul>
<li>
<a class="el" href="_users_guide.html#UG_Intro">Introduction</a> <ul>
<li>
<a class="el" href="_users_guide.html#UG_WhatIsIon">What Is Ion?</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_AboutThisGuide">About This Guide</a> </li>
</ul>
</li>
<li>
<a class="el" href="_users_guide.html#UG_Libraries">Ion Libraries</a> <ul>
<li>
<a class="el" href="_users_guide.html#UG_CoreLibraries">Core Ion Libraries</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_OptionalLibraries">Optional Ion Libraries</a> </li>
</ul>
</li>
<li>
<a class="el" href="_users_guide.html#UG_Building">Building an Application with Ion</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_MainClasses">The Main Ion Classes</a> <ul>
<li>
<a class="el" href="_users_guide.html#UG_SceneConstruction">Scene Construction</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_SceneRendering">Scene Rendering</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_SmartPointers">Smart Pointers</a> </li>
</ul>
</li>
<li>
<a class="el" href="_users_guide.html#UG_Rectangle_Example">Example 1: Drawing a Rectangle</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_Shaders_Example">Example 2: Specifying Shaders</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_Texture_Example">Example 3: Adding a Texture</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_Shape_Example">Example 4: Creating a Shape Explicitly</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_Hierarchy_Example">Example 5: Creating a Node Hierarchy</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_Multipass_Example">Example 6: Using Framebuffer Objects for Multipass Rendering</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_Mapped_Example">Example 7: Using Mapped Buffers</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_Sharing_Example">Example 8: Sharing Objects</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_Text_Example">Example 9: Adding Text</a> </li>
<li>
<a class="el" href="_users_guide.html#UG_DevelopmentTools">Development Tools</a> </li>
</ul>
<hr/>
 <h1><a class="anchor" id="UG_Intro"></a>
Introduction</h1>
<h2><a class="anchor" id="UG_WhatIsIon"></a>
What Is Ion?</h2>
<p>Ion is a set of C++ libraries that make it easier to develop cross-platform applications, especially those that use 3D graphics. Ion exposes most of the power and flexibility of <a href="http://www.opengl.org/">OpenGL</a> while presenting a friendlier programming model. Ion also includes several run-time tools that make developing applications easier and faster.</p>
<h2><a class="anchor" id="UG_AboutThisGuide"></a>
About This Guide</h2>
<p>This users guide is intended to help you get started using Ion in your projects. It assumes that you are reasonably familiar with C++, OpenGL (especially the <a href="http://www.khronos.org/opengles">OpenGL ES</a> variants), and 3D graphics in general. It also assumes that you are comfortable with the basics of creating applications for your platform(s), as Ion is focused heavily on the graphics components.</p>
<p>The guide begins with a brief description of the various Ion libraries and the main classes in it. Following that are programming examples illustrating how the classes are used and how everything fits together in applications.</p>
<p>Note that all classes and functions mentioned in this guide are assumed to be in the "ion" namespace. For example, the <a class="el" href="classion_1_1gfx_1_1_shader.html" title="A Shader represents an OpenGL shader stage. ">gfx::Shader</a> class is fully namespace-qualified as <a class="el" href="classion_1_1gfx_1_1_shader.html" title="A Shader represents an OpenGL shader stage. ">ion::gfx::Shader</a>.</p>
<hr/>
 <h1><a class="anchor" id="UG_Libraries"></a>
Ion Libraries</h1>
<p>Ion is organized into a set of core libraries that provide the main functionality and some additional higher-level libraries that provide optional conveniences and development aids. Ion also uses several third-party libraries, which are not discussed further here.</p>
<p>Each Ion library has its own source subdirectory (under the main "ion" directory) and its own namespace. For example, the <em>math</em> library is found in the <code>"ion/math"</code> subdirectory and its classes and functions are in the <a class="el" href="namespaceion_1_1math.html">ion::math</a> namespace.</p>
<p><div class="dotgraph">
<img src="dot_libraries.png" alt="dot_libraries.png" border="0" usemap="#dot_libraries.map"/>
<map name="dot_libraries.map" id="dot_libraries.map"></map>
</div>
</p>
<h2><a class="anchor" id="UG_CoreLibraries"></a>
Core Ion Libraries</h2>
<p>The core libraries are as follows:</p>
<ul>
<li><b>port</b> is the lowest-level Ion library. It contains only types and functions that implement platform-dependent operations through a platform-independent API.</li>
</ul>
<ul>
<li><b>base</b> contains some basic types and functions that enrich the programming environment and reduce complexity and redundancy in the rest of the code base. Included in this library are memory management helpers, data containers, string utility functions, error message logging, threading utilities, and lots more.</li>
</ul>
<ul>
<li><b>portgfx</b> is similar to the <code>port</code> library in that it hides platform-dependent details behind a platform-independent API, but it is specifically for graphics functions. That is, it hides OpenGL implementation details that vary between platforms.</li>
</ul>
<ul>
<li><b>math</b> contains classes and functions that implement algebraic and geometric operations. Examples include vectors and matrices of different dimensions, along with angles, ranges, and rotations. These classes and functions form the basis for many of the geometric entities in a graphics application.</li>
</ul>
<ul>
<li><b>gfx</b> is the principal Ion library. It provides classes that are used to represent graphical scenes and the operations used to render and interact with them in your application. This library is the primary focus of this guide.</li>
</ul>
<h2><a class="anchor" id="UG_OptionalLibraries"></a>
Optional Ion Libraries</h2>
<p>The optional, higher-level libraries all depend on the core libraries. They are as follows:</p>
<ul>
<li><b>gfxutils</b> contains a set of utility classes and functions that make it easier to create and operate on graphics objects. For example, there are utilities for creating objects that represent basic types of shapes.</li>
</ul>
<ul>
<li><b>image</b> provides a minimal set of utilities for operating on images, such as converting between formats and rendering textures to images.</li>
</ul>
<ul>
<li><b>text</b> contains classes and functions that help you insert 3D text into your scene.</li>
</ul>
<ul>
<li><b>profile</b> contains types and functions to help with collecting run-time performance data. Note that profiling requires specialized build flags and is not available by default.</li>
</ul>
<ul>
<li><b>analytics</b> provides some classes and functions for benchmarking and analyzing performance of your applications.</li>
</ul>
<ul>
<li><b>remote</b> contains several run-time handlers that you can include in your application to facilitate development. Each handler provides a browser-based user interface that lets you interact with your application. For example, you can modify application-specific settings, examine OpenGL resource use, and edit shader code on the fly.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="UG_Building"></a>
Building an Application with Ion</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Fill this in with open-source building info.</dd></dl>
<hr/>
 <h1><a class="anchor" id="UG_MainClasses"></a>
The Main Ion Classes</h1>
<p>This section provides a brief overview of the main Ion classes. It is not intended to be thorough; there is just enough information to make it easier to understand the examples in the rest of the guide.</p>
<h2><a class="anchor" id="UG_SceneConstruction"></a>
Scene Construction</h2>
<p>One of the main ways Ion makes application development easier is by storing objects that represent graphics data. OpenGL is primarily an <em>immediate mode</em> library, meaning that commands issued through it are typically handled immediately by the hardware driver implementation. It also allows you to create certain run-time objects (such as vertex buffer objects and framebuffer objects) that represent the results of issuing those commands, but these objects are usually opaque to the caller and cannot be modified easily. Ion, on the other hand, is a <em>retained mode</em> library, meaning that it stores persistent run-time objects that represent the graphics data. Having these editable run-time objects makes it easier for you to examine the data and to make changes. The Ion objects are designed to be very thin wrappers around the actual OpenGL commands, so there is minimal overhead in using them.</p>
<p>The main classes involved in scene construction are as follows:</p>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_node.html" title="A Node instance represents a node in a scene graph. ">gfx::Node</a> is the basic unit of scene representation. A Node may contain any number of shapes to render, along with a shader program, uniform values, and other state to apply to those shapes. A Node may also have other Nodes as children, allowing Node hierarchies to be created. Graphics state is inherited from parent Nodes to child Nodes, so structuring scenes in this way can result in very efficient rendering traversals.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_shape.html" title="A Shape object represents a shape (vertices + indices) to draw. ">gfx::Shape</a> represents a visible geometric object in a scene, specified as a collection of vertices and (optionally) indices into the vertices.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_attribute_array.html" title="An AttributeArray represents a collection of Attributes used to describe the vertices of a Shape...">gfx::AttributeArray</a> stores vertex information as a collection of <code><a class="el" href="classion_1_1gfx_1_1_attribute.html">gfx::Attribute</a></code>s for use in a Shape.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_index_buffer.html" title="An IndexBuffer is a type of BufferObject that contains the element indices of an array, e.g., a vertex index array. ">gfx::IndexBuffer</a> stores an array of vertex indices for use in a Shape.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_shader_program.html" title="A ShaderProgram represents an OpenGL shader program that can be applied to shapes. ">gfx::ShaderProgram</a> represents an OpenGL shader program, referring to both a vertex shader and fragment shader (each as a <a class="el" href="classion_1_1gfx_1_1_shader.html" title="A Shader represents an OpenGL shader stage. ">gfx::Shader</a>). Ion requires that every ShaderProgram makes all of its inputs (uniforms and attributes) known ahead of time through the use of an <a class="el" href="classion_1_1gfx_1_1_shader_input_registry.html" title="A ShaderInputRegistry is used to manage a collection of shader inputs to a specific ShaderProgram (bo...">gfx::ShaderInputRegistry</a>.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_uniform.html" title="A Uniform instance represents a uniform shader argument. ">gfx::Uniform</a> and <a class="el" href="classion_1_1gfx_1_1_uniform_block.html" title="A UniformBlock is a grouping of uniforms that can be easily shared between multiple Nodes; changing a...">gfx::UniformBlock</a> are used to set values for OpenGL shader uniforms.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_texture.html" title="A Texture object represents the image data and mipmaps associated with a single texture. ">gfx::Texture</a> and <a class="el" href="classion_1_1gfx_1_1_cube_map_texture.html" title="A CubeMapTexture object represents the image data and mipmaps associated with the six faces of a cube...">gfx::CubeMapTexture</a> represent textures that can be applied to Shapes. A texture uses a <a class="el" href="classion_1_1gfx_1_1_sampler.html" title="A Sampler object represents texture parameters that control how texture data is accessed in shaders...">gfx::Sampler</a> to specify its texture parameters and is stored in a <a class="el" href="classion_1_1gfx_1_1_uniform.html" title="A Uniform instance represents a uniform shader argument. ">gfx::Uniform</a>.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_state_table.html" title="A StateTable represents a collection of graphical state items that affect OpenGL rendering. ">gfx::StateTable</a> represents global graphical state that affects rendering, such as blend functions, line width, stenciling, and so on.</li>
</ul>
<h2><a class="anchor" id="UG_SceneRendering"></a>
Scene Rendering</h2>
<p>Once you have constructed a scene from one or more Nodes, you would probably like to render that scene onto the screen or into an image. These classes are used to do just that:</p>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_renderer.html" title="The Renderer class handles rendering ION scene graphs using OpenGL. ">gfx::Renderer</a> provides the interface for rendering Ion data with OpenGL. The <a class="el" href="classion_1_1gfx_1_1_renderer.html#ac13a3bd2eb6fb1854ff2b1550c40dc54" title="Draws the scene rooted by the given node into the currently bound framebuffer. ">gfx::Renderer::DrawScene()</a> function renders whatever scene is represented by the Node passed to it. You can call this function any number of times to render multiple scenes or parts of scenes.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_framebuffer_object.html" title="A FramebufferObject describes an off-screen framebuffer that can be drawn to and read from like a reg...">gfx::FramebufferObject</a> represents an off-screen framebuffer that can be used as a target for rendering instead of the display screen. You can call <a class="el" href="classion_1_1gfx_1_1_renderer.html#a2d8dcaec87d0c04f51726301060fcfd5" title="Binds the passed FramebufferObject; all future calls to DrawScene() will be drawn into it...">gfx::Renderer::BindFramebuffer()</a> to change the rendering target.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_graphics_manager.html" title="GraphicsManager manages the graphics library for an application. ">gfx::GraphicsManager</a> is used by the Renderer as an intermediary to all OpenGL functions. It permits OpenGL extensions to be used easily and can also trace all OpenGL calls and detect errors. Applications typically do not have to use this class directly.</li>
</ul>
<h2><a class="anchor" id="UG_SmartPointers"></a>
Smart Pointers</h2>
<p>As a result of Ion's very general scene construction model, ownership of several types objects can be shared. Here are some examples:</p>
<ul>
<li>A Node may be added as a child of several other Nodes. </li>
<li>Several ShaderPrograms may use the same ShaderInputRegistry. </li>
<li>A ShaderProgram or Shape may be shared by any number of Nodes. </li>
<li>Several Shapes may share an AttributeArray or IndexBuffer.</li>
</ul>
<p>To make these operations easier, most shareable objects in Ion are derived from <a class="el" href="classion_1_1base_1_1_referent.html" title="Thread-safe abstract base class. ">base::Referent</a>, which is an abstract base class that implements intrusive thread-safe reference counting. Each derived class has a corresponding <code>typedef</code> for a <a class="el" href="classion_1_1base_1_1_shared_ptr.html" title="A SharedPtr is a smart shared pointer to an instance of some class that implements reference counting...">base::SharedPtr</a> to itself. For example, the <a class="el" href="classion_1_1gfx_1_1_shader.html" title="A Shader represents an OpenGL shader stage. ">gfx::Shader</a> class header defines <a class="el" href="namespaceion_1_1gfx.html#a3cdd7323c1a3246f97b79277b3845054" title="Convenience typedef for shared pointers to Shaders. ">gfx::ShaderPtr</a> for convenience.</p>
<p>You may notice that many functions in Ion receive objects by const reference to smart pointers, as in this member function in the <a class="el" href="classion_1_1gfx_1_1_node.html" title="A Node instance represents a node in a scene graph. ">gfx::Node</a> class: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> AddChild(<span class="keyword">const</span> <a class="code" href="namespaceion_1_1gfx.html#a07b06fd55473ad00ef896315ae2f6c46">gfx::NodePtr</a>&amp; child);</div>
</div><!-- fragment --><p> This convention provides the advantage of using smart pointers for safety while avoiding unnecessary increments and decrements to the reference count just to pass parameters.</p>
<p>There is also an <a class="el" href="classion_1_1base_1_1_weak_referent_ptr.html" title="A WeakReferentPtr is a weak reference to an instance of some class derived from Referent. ">base::WeakReferentPtr</a> for situations in which a weak pointer to a derived Referent class is needed.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classion_1_1base_1_1_shared_ptr.html" title="A SharedPtr is a smart shared pointer to an instance of some class that implements reference counting...">base::SharedPtr</a> may be replaced with <code>std::shared_ptr</code> in the future. However, if you use the typedefs, this change should not be very noticeable.</dd></dl>
<hr/>
 <div class="image">
<img src="rectangle_thumbnail.png"  style="float: right; width: 180px; margin-left: 20px" alt="Rectangle Thumbnail"/>
</div>
<h1><a class="anchor" id="UG_Rectangle_Example"></a>
Example 1: Drawing a Rectangle</h1>
<p><br/>
</p>
<p>Time for the first example: drawing a rectangle on the screen (source file <code><a class="el" href="rectangle_8cc.html">examples/rectangle.cc</a></code>). This can be considered a "hello world" program for Ion. It creates a Node with a Shape that represents a yellow rectangle, along with the minimum state necessary to make the rectangle show up correctly.</p>
<dl class="section note"><dt>Note</dt><dd>All of these examples use the <a href="http://freeglut.sourceforge.net">FreeGLUT</a> library to create and manage a window, establish an OpenGL context, and provide (minimal) interaction. FreeGLUT has a very simple callback-based API, making the examples small and easy to understand.</dd></dl>
<p>Here are all the system and Ion headers used in the example:</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">ion/gfx/node.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="renderer_8h.html">ion/gfx/renderer.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shaderinputregistry_8h.html">ion/gfx/shaderinputregistry.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shape_8h.html">ion/gfx/shape.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="statetable_8h.html">ion/gfx/statetable.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="uniform_8h.html">ion/gfx/uniform.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shapeutils_8h.html">ion/gfxutils/shapeutils.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix_8h.html">ion/math/matrix.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="range_8h.html">ion/math/range.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="vector_8h.html">ion/math/vector.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;GL/freeglut.h&quot;</span></div>
</div><!-- fragment --></p>
<p>Next we define a <code>GlobalState</code> struct, which encapsulates all of the state required by our FreeGLUT callbacks. We maintain an instance as a global variable, since there is no way to pass any user-defined data to the callbacks:</p>
<p><div class="fragment"><div class="line"><span class="keyword">struct </span>GlobalState {</div>
<div class="line">  <span class="keywordtype">int</span> window_width;</div>
<div class="line">  <span class="keywordtype">int</span> window_height;</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::NodePtr</a> scene_root;</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::RendererPtr</a> renderer;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> std::unique_ptr&lt;GlobalState&gt; s_global_state;</div>
</div><!-- fragment --></p>
<p>The <code>BuildGraph()</code> function creates and returns the <a class="el" href="classion_1_1gfx_1_1_node.html" title="A Node instance represents a node in a scene graph. ">gfx::Node</a> that represents the rectangle. It starts by creating the (root) node. Note the use of <a class="el" href="namespaceion_1_1gfx.html#a07b06fd55473ad00ef896315ae2f6c46">gfx::NodePtr</a>, which is a <a class="el" href="classion_1_1base_1_1_shared_ptr.html" title="A SharedPtr is a smart shared pointer to an instance of some class that implements reference counting...">base::SharedPtr</a> typedef:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::NodePtr</a> BuildGraph(<span class="keywordtype">int</span> window_width, <span class="keywordtype">int</span> window_height) {</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::NodePtr</a> root(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_node.html">ion::gfx::Node</a>);</div>
</div><!-- fragment --></p>
<p>It next uses the convenient <a class="el" href="namespaceion_1_1gfxutils.html#a19704a34023915117bd708720f8071ac" title="Builds and returns a Shape representing a rectangle in one of the principal Cartesian planes...">gfxutils::BuildRectangleShape()</a> function to create the Shape. Since we are not doing any complicated shading, we request just vertex positions to be created. (Other optional components are surface normals and texture coordinates.) We also set the size of the rectangle to 2x2 units so it ranges from -1 to 1 in X and Y. The Shape is added to the node:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="struction_1_1gfxutils_1_1_rectangle_spec.html">ion::gfxutils::RectangleSpec</a> rect_spec;</div>
<div class="line">  rect_spec.<a class="code" href="struction_1_1gfxutils_1_1_shape_spec.html#a75239dc259c47d93f22c079f85d4a573">vertex_type</a> = <a class="code" href="struction_1_1gfxutils_1_1_shape_spec.html#ae60ce070bca33d819e89a67fbc0218e8a9665c416d0f6f086d51a125225623a22">ion::gfxutils::ShapeSpec::kPosition</a>;</div>
<div class="line">  rect_spec.<a class="code" href="struction_1_1gfxutils_1_1_rectangle_spec.html#a9cc61d0fb3165e8cd083c122c181e13d">size</a>.Set(2.f, 2.f);</div>
<div class="line">  root-&gt;AddShape(<a class="code" href="namespaceion_1_1gfxutils.html#a19704a34023915117bd708720f8071ac">ion::gfxutils::BuildRectangleShape</a>(rect_spec));</div>
</div><!-- fragment --></p>
<p>The next step is to set up a <a class="el" href="classion_1_1gfx_1_1_state_table.html" title="A StateTable represents a collection of graphical state items that affect OpenGL rendering. ">gfx::StateTable</a> with the state needed to render correctly. The window sizes are used to set up the viewport. We also set the clear color and depth-clear values, and enable depth test and back-face culling. (The latter two settings are not really needed for a single rectangle, but they are typically enabled for most 3D scenes). The StateTable is set in the node:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::StateTablePtr</a> state_table(</div>
<div class="line">      <span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_state_table.html">ion::gfx::StateTable</a>(window_width, window_height));</div>
<div class="line">  state_table-&gt;SetViewport(</div>
<div class="line">      ion::math::Range2i::BuildWithSize(ion::math::Point2i(0, 0),</div>
<div class="line">                                        ion::math::Vector2i(window_width,</div>
<div class="line">                                                            window_height)));</div>
<div class="line">  state_table-&gt;SetClearColor(ion::math::Vector4f(0.3f, 0.3f, 0.5f, 1.0f));</div>
<div class="line">  state_table-&gt;SetClearDepthValue(1.f);</div>
<div class="line">  state_table-&gt;Enable(<a class="code" href="classion_1_1gfx_1_1_state_table.html#ae6f345fc251ac53d5797d6300859d665abdb5a45264717df82a5d4c566cfc4868">ion::gfx::StateTable::kDepthTest</a>, <span class="keyword">true</span>);</div>
<div class="line">  state_table-&gt;Enable(<a class="code" href="classion_1_1gfx_1_1_state_table.html#ae6f345fc251ac53d5797d6300859d665a3cba54f28abf33e3b45e643c00657d3b">ion::gfx::StateTable::kCullFace</a>, <span class="keyword">true</span>);</div>
<div class="line">  root-&gt;SetStateTable(state_table);</div>
</div><!-- fragment --></p>
<p>Next we need to set some uniform values in the node. You may notice that we did not specify a <a class="el" href="classion_1_1gfx_1_1_shader_program.html" title="A ShaderProgram represents an OpenGL shader program that can be applied to shapes. ">gfx::ShaderProgram</a> for the node, meaning that Ion will use the <em>default shader program</em> when rendering its contents. The default program defines a vertex shader that just transforms each vertex by projection and modelview matrices and a fragment shader that just sets each fragment to a base color. The matrices and color are defined as uniform values in the <em>global shader input registry</em>, which is used by the default program. (Uniforms are specified by name; in this case, the three we care about are called <code>"uProjectionMatrix"</code>, <code>"uModelviewMatrix"</code>, and <code>"uBaseColor"</code>.) Therefore, we first access the global registry, then use it to create <a class="el" href="classion_1_1gfx_1_1_uniform.html" title="A Uniform instance represents a uniform shader argument. ">gfx::Uniform</a> values, which we then add to the node:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::ShaderInputRegistryPtr</a>&amp; global_reg =</div>
<div class="line">      <a class="code" href="classion_1_1gfx_1_1_shader_input_registry.html#a1934f3318dea59fbb9b317fec976dcf5">ion::gfx::ShaderInputRegistry::GetGlobalRegistry</a>();</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classion_1_1math_1_1_matrix.html">ion::math::Matrix4f</a> proj(1.732f, 0.0f, 0.0f, 0.0f,</div>
<div class="line">                                 0.0f, 1.732f, 0.0f, 0.0f,</div>
<div class="line">                                 0.0f, 0.0f, -1.905f, -13.798f,</div>
<div class="line">                                 0.0f, 0.0f, -1.0f, 0.0f);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classion_1_1math_1_1_matrix.html">ion::math::Matrix4f</a> view(1.0f, 0.0f, 0.0f, 0.0f,</div>
<div class="line">                                 0.0f, 1.0f, 0.0f, 0.0f,</div>
<div class="line">                                 0.0f, 0.0f, 1.0f, -5.0f,</div>
<div class="line">                                 0.0f, 0.0f, 0.0f, 1.0f);</div>
<div class="line">  root-&gt;AddUniform(global_reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uProjectionMatrix&quot;</span>, proj));</div>
<div class="line">  root-&gt;AddUniform(global_reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uModelviewMatrix&quot;</span>, view));</div>
<div class="line">  root-&gt;AddUniform(global_reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uBaseColor&quot;</span>, ion::math::Vector4f(1.f, 1.f, 0.f, 1.f)));</div>
</div><!-- fragment --></p>
<p>All that is left to do is return the node we built:</p>
<p><div class="fragment"><div class="line">  <span class="keywordflow">return</span> root;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>We define a FreeGLUT display function callback, which is called <code>Render()</code>. It just calls the <a class="el" href="classion_1_1gfx_1_1_renderer.html#ac13a3bd2eb6fb1854ff2b1550c40dc54" title="Draws the scene rooted by the given node into the currently bound framebuffer. ">gfx::Renderer::DrawScene()</a> function, passing the node we created, then asks FreeGLUT to swap buffers:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> Render() {</div>
<div class="line">  <span class="keywordflow">if</span> (s_global_state.get())</div>
<div class="line">    s_global_state-&gt;renderer-&gt;DrawScene(s_global_state-&gt;scene_root);</div>
<div class="line">  glutSwapBuffers();</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>The mainline for the program is mostly concerned with initializing and running FreeGLUT. The first chunk of Ion-specific code involves setting up the GlobalState:</p>
<p><div class="fragment"><div class="line">  s_global_state.reset(<span class="keyword">new</span> GlobalState);</div>
<div class="line">  s_global_state-&gt;window_width = s_global_state-&gt;window_height = 800;</div>
<div class="line">  s_global_state-&gt;scene_root = BuildGraph(s_global_state-&gt;window_width,</div>
<div class="line">                                          s_global_state-&gt;window_height);</div>
</div><!-- fragment --></p>
<p>After initializing FreeGLUT, we set up the <a class="el" href="classion_1_1gfx_1_1_renderer.html" title="The Renderer class handles rendering ION scene graphs using OpenGL. ">gfx::Renderer</a> in the GlobalState along with a <a class="el" href="classion_1_1gfx_1_1_graphics_manager.html" title="GraphicsManager manages the graphics library for an application. ">gfx::GraphicsManager</a> (which requires a FreeGLUT context for proper initialization):</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::GraphicsManagerPtr</a> graphics_manager(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_graphics_manager.html">ion::gfx::GraphicsManager</a>);</div>
<div class="line">  s_global_state-&gt;renderer.Reset(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_renderer.html">ion::gfx::Renderer</a>(graphics_manager));</div>
</div><!-- fragment --></p>
<p>Running this program should result in a dark blue 800x800 pixel window with a yellow rectangle in the middle. Pressing the escape button should cause the program to terminate.</p>
<p>We will modify this program in the subsequent sections to illustrate more Ion features.</p>
<hr/>
 <div class="image">
<img src="shaders_thumbnail.png"  style="float: right; width: 180px; margin-left: 20px" alt="Shaders Thumbnail"/>
</div>
<h1><a class="anchor" id="UG_Shaders_Example"></a>
Example 2: Specifying Shaders</h1>
<p><br/>
</p>
<p>In this example, we define and use a <a class="el" href="classion_1_1gfx_1_1_shader_program.html" title="A ShaderProgram represents an OpenGL shader program that can be applied to shapes. ">gfx::ShaderProgram</a> with custom vertex and fragment shaders (source code in <code><a class="el" href="shaders_8cc.html">examples/shaders.cc</a></code>) applied to the rectangle from the previous example. For brevity and clarity, we describe only the code differences from that example in this section.</p>
<p>The only additional header file we need is:</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shaderprogram_8h.html">ion/gfx/shaderprogram.h</a>&quot;</span></div>
</div><!-- fragment --></p>
<p>Next we specify the source code for the vertex and fragment shaders. We define the code here as C++ strings for simplicity, but writing the code this way can be tedious and error-prone. See the <a class="el" href="_users_guide.html#UG_DevelopmentTools">Development Tools</a> section for better options.</p>
<p>The example shaders apply a color gradient from the top to the bottom of the rectangle and also simulate diffuse illumination of a wavy surface from left to right. The vertex shader takes care of computing the color gradient (using two colors passed as uniforms) and passes that along with the object-space position to the fragment shader as <code>varying</code> variables (<code>vColor</code> and <code>vPosition</code>, respectively). It also takes care of transforming the object-space vertex position to clip space as usual:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kVertexShaderString = (</div>
<div class="line">    <span class="stringliteral">&quot;uniform mat4 uProjectionMatrix;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;uniform mat4 uModelviewMatrix;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;uniform vec4 uTopColor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;uniform vec4 uBottomColor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;attribute vec3 aVertex;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;varying vec3 vPosition;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;varying vec4 vColor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;void main(void) {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vPosition = aVertex;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vColor = mix(uBottomColor, uTopColor, .5 * (1. + vPosition.y));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  gl_Position = uProjectionMatrix * uModelviewMatrix *\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;      vec4(aVertex, 1.);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;}\n&quot;</span>);</div>
</div><!-- fragment --></p>
<p>Note that the gradient computation relies on the fact that the Y coordinates of the rectangle range from -1 to 1; this is done purely to keep the example simple.</p>
<p>The fragment shader simulates the wavy surface illumination by generating a surface normal based on a sine wave applied to the X coordinate of the rectangle (again, assumed to range from -1 to 1). The frequency of the wave is passed to the shader as a uniform:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kFragmentShaderString = (</div>
<div class="line">    <span class="stringliteral">&quot;#ifdef GL_ES\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;precision highp float;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;#else\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;precision mediump float;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;#endif\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;#endif\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;uniform float uWaveFrequency;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;varying vec3 vPosition;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;varying vec4 vColor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;void main(void) {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  float nx = sin(uWaveFrequency * radians(90.) * vPosition.x);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vec3 normal = normalize(vec3(nx, 0., .5));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vec3 dir_to_light = normalize(vec3(1., 2., 10.));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  float intensity = max(0.0, dot(dir_to_light, normal));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  gl_FragColor = intensity * vColor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;}\n&quot;</span>);</div>
</div><!-- fragment --></p>
<p>You may notice that there are a few lines at the beginning of the fragment shader source that deal with precision. This code is unfortunately necessary at present if you plan to run your application on platforms that use <a href="http://www.khronos.org/opengles">OpenGL ES</a> (typically mobile devices).</p>
<p>The next chunk of new code is in the <code>BuildGraph()</code> function. It creates a new <a class="el" href="classion_1_1gfx_1_1_shader_input_registry.html" title="A ShaderInputRegistry is used to manage a collection of shader inputs to a specific ShaderProgram (bo...">gfx::ShaderInputRegistry</a> for the custom shader program. A <a class="el" href="classion_1_1gfx_1_1_shader_input_registry.html" title="A ShaderInputRegistry is used to manage a collection of shader inputs to a specific ShaderProgram (bo...">gfx::ShaderInputRegistry</a>, as its name suggests, registers the inputs that will be used for a shader program. Each input is specified with its name, value type, and a description string. You may recall that in the preceding <a class="el" href="_users_guide.html#UG_Rectangle_Example">rectangle example</a> we relied on the global shader input registry, which defines inputs used for the default shader program. We want to use some of those inputs (namely <code>uProjectionMatrix</code> and <code>uModelviewMatrix</code>) here as well, so we make sure to include the global registry in the new one, which makes those inputs accessible in our new registry. (Note that you can also use the <a class="el" href="classion_1_1gfx_1_1_shader_input_registry.html#a470aaedd1471b8fffb55e226d355cd2d" title="Includes another ShaderInputRegistry in this one. ">gfx::ShaderInputRegistry::Include()</a> function to include any registry in any other registry, as long as their inputs are distinct.) Then we add our three new uniforms to the registry:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::ShaderInputRegistryPtr</a> reg(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_shader_input_registry.html">ion::gfx::ShaderInputRegistry</a>);</div>
<div class="line">  reg-&gt;IncludeGlobalRegistry();</div>
<div class="line">  reg-&gt;Add(<a class="code" href="struction_1_1gfx_1_1_shader_input_registry_1_1_spec.html">ion::gfx::ShaderInputRegistry::UniformSpec</a>(</div>
<div class="line">      <span class="stringliteral">&quot;uTopColor&quot;</span>, <a class="code" href="namespaceion_1_1gfx.html#a08bbfe864fd7c473f2873534535a9643ac4e47e833e681048f10c0fbd01932b06">ion::gfx::kFloatVector4Uniform</a>,</div>
<div class="line">      <span class="stringliteral">&quot;Color at the top of the rectangle&quot;</span>));</div>
<div class="line">  reg-&gt;Add(<a class="code" href="struction_1_1gfx_1_1_shader_input_registry_1_1_spec.html">ion::gfx::ShaderInputRegistry::UniformSpec</a>(</div>
<div class="line">      <span class="stringliteral">&quot;uBottomColor&quot;</span>, <a class="code" href="namespaceion_1_1gfx.html#a08bbfe864fd7c473f2873534535a9643ac4e47e833e681048f10c0fbd01932b06">ion::gfx::kFloatVector4Uniform</a>,</div>
<div class="line">      <span class="stringliteral">&quot;Color at the bottom of the rectangle&quot;</span>));</div>
<div class="line">  reg-&gt;Add(<a class="code" href="struction_1_1gfx_1_1_shader_input_registry_1_1_spec.html">ion::gfx::ShaderInputRegistry::UniformSpec</a>(</div>
<div class="line">      <span class="stringliteral">&quot;uWaveFrequency&quot;</span>, <a class="code" href="namespaceion_1_1gfx.html#a08bbfe864fd7c473f2873534535a9643a08f89b65739f59e8d7ec80c6ba321108">ion::gfx::kFloatUniform</a>,</div>
<div class="line">      <span class="stringliteral">&quot;Frequency of the sine wave applied to the rectangle normal&quot;</span>));</div>
</div><!-- fragment --></p>
<p>Next we use a convenience function that constructs a <a class="el" href="classion_1_1gfx_1_1_shader.html" title="A Shader represents an OpenGL shader stage. ">gfx::Shader</a> instance for each of the two shaders and installs them in a new <a class="el" href="classion_1_1gfx_1_1_shader_program.html" title="A ShaderProgram represents an OpenGL shader program that can be applied to shapes. ">gfx::ShaderProgram</a>, which we then install in the node:</p>
<p><div class="fragment"><div class="line">  root-&gt;SetShaderProgram(</div>
<div class="line">      <a class="code" href="classion_1_1gfx_1_1_shader_program.html#a0c48ae4682ac587930ab2e604de1a588">ion::gfx::ShaderProgram::BuildFromStrings</a>(</div>
<div class="line">          <span class="stringliteral">&quot;Example shader&quot;</span>, reg, kVertexShaderString,</div>
<div class="line">          kFragmentShaderString, <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::base::AllocatorPtr</a>()));</div>
</div><!-- fragment --></p>
<p>Finally, we add uniforms with reasonable values to the node. Note that we use our new registry to create the uniforms:</p>
<p><div class="fragment"><div class="line">  root-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(<span class="stringliteral">&quot;uProjectionMatrix&quot;</span>, proj));</div>
<div class="line">  root-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(<span class="stringliteral">&quot;uModelviewMatrix&quot;</span>, view));</div>
<div class="line">  root-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uTopColor&quot;</span>, ion::math::Vector4f(1.f, .5f, .5f, 1.f)));</div>
<div class="line">  root-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uBottomColor&quot;</span>, ion::math::Vector4f(.5f, .5f, 1.f, 1.f)));</div>
<div class="line">  root-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(<span class="stringliteral">&quot;uWaveFrequency&quot;</span>, 5.f));</div>
</div><!-- fragment --></p>
<p>The rest of the code is identical to that in the previous example.</p>
<hr/>
 <div class="image">
<img src="texture_thumbnail.png"  style="float: right; width: 180px; margin-left: 20px" alt="Texture Thumbnail"/>
</div>
<h1><a class="anchor" id="UG_Texture_Example"></a>
Example 3: Adding a Texture</h1>
<p><br/>
</p>
<p>In this example, we modify the shaders from the previous example to apply a simple RGB texture to the rectangle instead of a color gradient, while still simulating the wavy illumination. We also demonstrate a little bit of matrix math to set up a texture matrix. The source code is in <code><a class="el" href="doc_2usersguide_2examples_2texture_8cc.html">examples/texture.cc</a></code>.</p>
<p>We need some additional header files for this example:</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="datacontainer_8h.html">ion/base/datacontainer.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="sampler_8h.html">ion/gfx/sampler.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="texture_8h.html">ion/gfx/texture.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="angle_8h.html">ion/math/angle.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="transformutils_8h.html">ion/math/transformutils.h</a>&quot;</span></div>
</div><!-- fragment --></p>
<p>The vertex shader is similar to that in the previous example, except that it sets up varying texture coordinates (<code>vTexCoords</code>) instead of a color. The texture coordinates are modified by a matrix that is passed in as a uniform (<code>uTextureMatrix</code>):</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kVertexShaderString = (</div>
<div class="line">    <span class="stringliteral">&quot;uniform mat4 uProjectionMatrix;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;uniform mat4 uModelviewMatrix;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;uniform mat4 uTextureMatrix;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;attribute vec3 aVertex;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;attribute vec2 aTexCoords;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;varying vec3 vPosition;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;varying vec2 vTexCoords;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;void main(void) {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vTexCoords = (uTextureMatrix * vec4(aTexCoords, 0., 1.)).st;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vPosition = aVertex;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  gl_Position = uProjectionMatrix * uModelviewMatrix *\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;      vec4(aVertex, 1.);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;}\n&quot;</span>);</div>
</div><!-- fragment --></p>
<p>The fragment shader uses the texture coordinates to access the correct fragment color from the texture, which is passed in as the <code>uSampler</code> uniform. (Note that the word "sampler" is used here in a GLSL sense to mean a way to sample values, as opposed to its upcoming use in an OpenGL sense, where it is an object that stores sampling parameters for a texture. Sorry for the confusion.) The rest of the shader is the same as before:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kFragmentShaderString = (</div>
<div class="line">    <span class="stringliteral">&quot;#ifdef GL_ES\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;precision highp float;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;#else\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;precision mediump float;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;#endif\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;#endif\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;uniform sampler2D uSampler;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;uniform float uWaveFrequency;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;varying vec3 vPosition;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;varying vec2 vTexCoords;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;void main(void) {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  float nx = sin(uWaveFrequency * radians(90.) * vPosition.x);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vec3 normal = normalize(vec3(nx, 0., .5));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vec3 dir_to_light = normalize(vec3(1., 2., 10.));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  float intensity = max(0.0, dot(dir_to_light, normal));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  gl_FragColor = intensity * texture2D(uSampler, vTexCoords);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;}\n&quot;</span>);</div>
</div><!-- fragment --></p>
<p>Next comes the code to set up the texture. First we define a function that creates and returns a 4x4 texture matrix to pass as the <code>uTextureMatrix</code> uniform. It rotates the texture by a specific angle around the center of the texture (which is .5 in both dimensions) using some of the handy Ion matrix utilities, solely for illustrative purposes:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classion_1_1math_1_1_matrix.html">ion::math::Matrix4f</a> BuildTextureRotationMatrix(<span class="keywordtype">float</span> degrees) {</div>
<div class="line">  <span class="keywordflow">return</span></div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#a4aef694ac9124b3bdd70ea1f8d431970">ion::math::TranslationMatrix</a>(ion::math::Vector3f(.5f, .5f, 0.f)) *</div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#ae8c54cc7645df57299eec2d2abf4db24">ion::math::RotationMatrixAxisAngleH</a>(</div>
<div class="line">          ion::math::Vector3f::AxisZ(),</div>
<div class="line">          ion::math::Anglef::FromDegrees(degrees)) *</div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#a4aef694ac9124b3bdd70ea1f8d431970">ion::math::TranslationMatrix</a>(ion::math::Vector3f(-.5f, -.5f, 0.f));</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>Note that Ion matrices are defined so that the translation by (-.5, -5) is first, followed by the rotation, followed by the translation by (.5, .5). See the comments at the beginning of <code><a class="el" href="transformutils_8h.html">ion/math/transformutils.h</a></code> for more details.</p>
<p>Next we define a function that builds and returns a <a class="el" href="classion_1_1gfx_1_1_texture.html" title="A Texture object represents the image data and mipmaps associated with a single texture. ">gfx::Texture</a>. Again, note the use of the <a class="el" href="namespaceion_1_1gfx.html#a898ebd00d721a2589edc7d818ff17533" title="Convenience typedef for shared pointer to a Texture. ">gfx::TexturePtr</a> smart pointer typedef as the return type:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::TexturePtr</a> BuildTexture() {</div>
</div><!-- fragment --></p>
<p>First, we define the data for the pixels of the texture image. The image is a very simple 2x2 square of RGB pixels, for a total of 2x2x3 = 12 bytes. Since OpenGL defines images starting with the bottom row, the first 6 bytes specify the bottom row and the next 6 specify the top row:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kWidth = 2;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kHeight = 2;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kRowSize = kWidth * 3;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> uint8 pixels[kHeight * kRowSize] = {</div>
<div class="line">    0xee, 0x22, 0xee,  0x00, 0x55, 0xdd,  <span class="comment">// Bottom row : magenta, blue.</span></div>
<div class="line">    0x00, 0xdd, 0xaa,  0xdd, 0xcc, 0x33,  <span class="comment">// Top row: green, yellow.</span></div>
<div class="line">  };</div>
</div><!-- fragment --></p>
<p>While using an explicit array of pixel data is a convenient way to set up an image in an example, it is not really that useful in real-world applications. More likely, you will want to create the image using data read from a file; the <a class="el" href="namespaceion_1_1image.html#a8fd4e5bc531e034473c28668ad152652" title="Converts external image data to an ImagePtr with data in canonical format. ">image::ConvertFromExternalImageData()</a> function can help with that. Also, you may find the <a class="el" href="classion_1_1base_1_1_zip_asset_manager.html" title="ZipAssetManager manages all zipfile assets in Ion. ">base::ZipAssetManager</a> class handy for embedding image data files and other assets directly in your application.</p>
<p>Next we create a <a class="el" href="classion_1_1gfx_1_1_image.html" title="An Image represents 2D image data that can be used in a texture supplied to a shader. ">gfx::Image</a> that represents the texture image. The <a class="el" href="classion_1_1gfx_1_1_image.html" title="An Image represents 2D image data that can be used in a texture supplied to a shader. ">gfx::Image</a> does not store the data directly. Instead, it uses a <a class="el" href="classion_1_1base_1_1_data_container.html" title="The DataContainer class encapsulates arbitrary user data passed to Ion. ">base::DataContainer</a>, which provides a very thin wrapper to encapsulate the data. The container provides three flexible but well-defined mechanisms for specifying the wrapped data; see the class documentation for details. We use the simplest form, which tells the container to copy our data into an allocated chunk of memory. Once we have the <a class="el" href="classion_1_1base_1_1_data_container.html" title="The DataContainer class encapsulates arbitrary user data passed to Ion. ">base::DataContainer</a> set up, we store it in the <a class="el" href="classion_1_1gfx_1_1_image.html" title="An Image represents 2D image data that can be used in a texture supplied to a shader. ">gfx::Image</a>:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::ImagePtr</a> <a class="code" href="sdfutils_8cc.html#a3555e065e55befd710eaa182fcf387f5">image</a>(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_image.html">ion::gfx::Image</a>);</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::base::DataContainerPtr</a> data_container =</div>
<div class="line">      ion::base::DataContainer::CreateAndCopy&lt;uint8&gt;(</div>
<div class="line">          pixels, <span class="keyword">sizeof</span>(pixels), <span class="keyword">true</span>, <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::base::AllocatorPtr</a>());</div>
<div class="line">  <a class="code" href="sdfutils_8cc.html#a3555e065e55befd710eaa182fcf387f5">image</a>-&gt;Set(<a class="code" href="classion_1_1gfx_1_1_image.html#a2215e7db780801d0c47f9b4b2713db9ea83c5984b5c87d5eb34561ce79f8ae78d">ion::gfx::Image::kRgb888</a>, kWidth, kHeight, data_container);</div>
</div><!-- fragment --></p>
<p>The <code>true</code> parameter passed to <a class="el" href="classion_1_1base_1_1_data_container.html#a7913600241ca4115220165e47fe5d5c5" title="See class comment for documentation. ">base::DataContainer::CreateAndCopy()</a> tells the container that the data is <em>wipeable</em>, meaning that Ion can deallocate the memory once it is no longer needed. For a <a class="el" href="classion_1_1gfx_1_1_image.html" title="An Image represents 2D image data that can be used in a texture supplied to a shader. ">gfx::Image</a>, this can happen as soon as an OpenGL texture object representing the texture that uses the image has been uploaded to the GPU. If you need to keep the data around for any reason, such as making modifications to it later on that cannot be done with <a class="el" href="classion_1_1gfx_1_1_texture.html#a58b4b2230062845e7cc09054b1cfdd67">gfx::Texture::SetSubImage()</a>, do not set this flag to true.</p>
<p>Next we create a <a class="el" href="classion_1_1gfx_1_1_sampler.html" title="A Sampler object represents texture parameters that control how texture data is accessed in shaders...">gfx::Sampler</a> that indicates how the texture is to be applied:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::SamplerPtr</a> sampler(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_sampler.html">ion::gfx::Sampler</a>);</div>
<div class="line">  sampler-&gt;SetWrapS(<a class="code" href="classion_1_1gfx_1_1_sampler.html#a0ba5458a2c1cfe30bd1347b50e3790dba20f4a4b5bbab9ff3a4ef3b9447d8f5f7">ion::gfx::Sampler::kClampToEdge</a>);</div>
<div class="line">  sampler-&gt;SetWrapT(<a class="code" href="classion_1_1gfx_1_1_sampler.html#a0ba5458a2c1cfe30bd1347b50e3790dba20f4a4b5bbab9ff3a4ef3b9447d8f5f7">ion::gfx::Sampler::kClampToEdge</a>);</div>
</div><!-- fragment --></p>
<p>Finally, we create a Texture using the image and sampler and return it:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::TexturePtr</a> <a class="code" href="fontimage_8cc.html#a05732ec89e3a90546399c62f2c7d90ac">texture</a>(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_texture.html">ion::gfx::Texture</a>);</div>
<div class="line">  <a class="code" href="fontimage_8cc.html#a05732ec89e3a90546399c62f2c7d90ac">texture</a>-&gt;SetImage(0U, <a class="code" href="sdfutils_8cc.html#a3555e065e55befd710eaa182fcf387f5">image</a>);</div>
<div class="line">  <a class="code" href="fontimage_8cc.html#a05732ec89e3a90546399c62f2c7d90ac">texture</a>-&gt;SetSampler(sampler);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="fontimage_8cc.html#a05732ec89e3a90546399c62f2c7d90ac">texture</a>;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>The <code>BuildGraph()</code> function in this example is very similar to the one in the previous example. The first difference is that we have to tell the <a class="el" href="namespaceion_1_1gfxutils.html#a19704a34023915117bd708720f8071ac" title="Builds and returns a Shape representing a rectangle in one of the principal Cartesian planes...">gfxutils::BuildRectangleShape()</a> function that we require texture coordinates in addition to vertex positions:</p>
<p><div class="fragment"><div class="line">  rect_spec.<a class="code" href="struction_1_1gfxutils_1_1_shape_spec.html#a75239dc259c47d93f22c079f85d4a573">vertex_type</a> = <a class="code" href="struction_1_1gfxutils_1_1_shape_spec.html#ae60ce070bca33d819e89a67fbc0218e8a9cdb8479c6fe03fc4549787d83e6dcdc">ion::gfxutils::ShapeSpec::kPositionTexCoords</a>;</div>
</div><!-- fragment --></p>
<p>Since we are using a different set of uniforms in our shaders, we no longer need to add the <code>uTopColor</code> and <code>uBottomColor</code> entries to the registry. Instead, we add the new uniforms used in the texture shaders:</p>
<p><div class="fragment"><div class="line">  reg-&gt;Add(<a class="code" href="struction_1_1gfx_1_1_shader_input_registry_1_1_spec.html">ion::gfx::ShaderInputRegistry::UniformSpec</a>(</div>
<div class="line">      <span class="stringliteral">&quot;uTextureMatrix&quot;</span>, <a class="code" href="namespaceion_1_1gfx.html#a08bbfe864fd7c473f2873534535a9643a0525286b6d441457ee2d3cd1f1390f07">ion::gfx::kMatrix4x4Uniform</a>,</div>
<div class="line">      <span class="stringliteral">&quot;Matrix applied to texture coordinates&quot;</span>));</div>
<div class="line">  reg-&gt;Add(<a class="code" href="struction_1_1gfx_1_1_shader_input_registry_1_1_spec.html">ion::gfx::ShaderInputRegistry::UniformSpec</a>(</div>
<div class="line">      <span class="stringliteral">&quot;uSampler&quot;</span>, <a class="code" href="namespaceion_1_1gfx.html#a08bbfe864fd7c473f2873534535a9643a1fb38ca96a9985f325f838de5757e95d">ion::gfx::kTextureUniform</a>,</div>
<div class="line">      <span class="stringliteral">&quot;Texture sampler&quot;</span>));</div>
</div><!-- fragment --></p>
<p>We define a local variable holding the texture matrix:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classion_1_1math_1_1_matrix.html">ion::math::Matrix4f</a> tex_mtx = BuildTextureRotationMatrix(30.f);</div>
</div><!-- fragment --></p>
<p>Then we add uniforms to the node:</p>
<p><div class="fragment"><div class="line">  root-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(<span class="stringliteral">&quot;uTextureMatrix&quot;</span>, tex_mtx));</div>
<div class="line">  root-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(<span class="stringliteral">&quot;uSampler&quot;</span>, BuildTexture()));</div>
</div><!-- fragment --></p>
<hr/>
 <div class="image">
<img src="shape_thumbnail.png"  style="float: right; width: 180px; margin-left: 20px" alt="Shape Thumbnail"/>
</div>
<h1><a class="anchor" id="UG_Shape_Example"></a>
Example 4: Creating a Shape Explicitly</h1>
<p>In the previous examples, we used the <a class="el" href="namespaceion_1_1gfxutils.html#a19704a34023915117bd708720f8071ac" title="Builds and returns a Shape representing a rectangle in one of the principal Cartesian planes...">gfxutils::BuildRectangleShape()</a> function to create a <a class="el" href="classion_1_1gfx_1_1_shape.html" title="A Shape object represents a shape (vertices + indices) to draw. ">gfx::Shape</a> to add to our node. If your application uses only basic shapes (such as rectangles, boxes, ellipsoids, cylinders) with only the predefined attributes (vertex positions, surface normals, and texture coordinates), feel free to use just this function and its kin. However, if you want to create more complex shapes, or if you need other types of attributes, you will need to write code to do that explicitly.</p>
<p>In this example, we modify the code from the previous example to explicitly create a simple pyramid shape. Each vertex of the pyramid has a position, a surface normal, and texture coordinates. For illustrative purposes, we also define an additional attribute for each vertex, a distance that is used to offset the vertex along the surface normal. For simplicity, we no longer apply the wavy illumination code. The source code is in <code><a class="el" href="doc_2usersguide_2examples_2shape_8cc.html">examples/shape.cc</a></code>.</p>
<p>As usual, we start with some additional header files:</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="attributearray_8h.html">ion/gfx/attributearray.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bufferobject_8h.html">ion/gfx/bufferobject.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="indexbuffer_8h.html">ion/gfx/indexbuffer.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="buffertoattributebinder_8h.html">ion/gfxutils/buffertoattributebinder.h</a>&quot;</span></div>
</div><!-- fragment --></p>
<p>However, we no longer need to include <code><a class="el" href="shapeutils_8h.html">ion/gfxutils/shapeutils.h</a></code>.</p>
<p>The vertex shader now uses the <code>aNormal</code> attribute from the global shader registry, so we declare that here. In addition, we create a custom attribute for the offset and a variable to pass the surface normal to the fragment shader. The new declarations are:</p>
<p><div class="fragment"><div class="line">    <span class="stringliteral">&quot;attribute vec3 aNormal;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;attribute float aOffsetAlongNormal;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;varying vec3 vNormal;\n&quot;</span></div>
</div><!-- fragment --></p>
<p>The new contents of the vertex shader are:</p>
<p><div class="fragment"><div class="line">    <span class="stringliteral">&quot;  vPosition = aVertex + aOffsetAlongNormal * aNormal;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vNormal = aNormal;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  gl_Position = uProjectionMatrix * uModelviewMatrix *\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;      vec4(vPosition, 1.);\n&quot;</span></div>
</div><!-- fragment --></p>
<p>In the fragment shader, we no longer declare the <code>uWaveFrequency</code> variable, but now we need the normal:</p>
<p><div class="fragment"><div class="line">    <span class="stringliteral">&quot;varying vec3 vNormal;\n&quot;</span></div>
</div><!-- fragment --></p>
<p>The shader code is pretty straightforward:</p>
<p><div class="fragment"><div class="line">    <span class="stringliteral">&quot;  vec3 dir_to_light = normalize(vec3(6., 3., 10.));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  float intensity = .3 * abs(dot(dir_to_light, vNormal));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  gl_FragColor = intensity * texture2D(uSampler, vTexCoords);\n&quot;</span></div>
</div><!-- fragment --></p>
<p>Note that we use the absolute value of the dot product instead of clamping it, allowing the back faces to be illuminated. We also turn the intensity down a bit to make things look a little more subdued.</p>
<p>You may also have noticed that the normals are not transformed along with the vertex positions. To do so properly would require using the inverse transpose of the object-to-world-space matrix. For clarity and brevity, we avoid doing that here by just computing the lighting in object space.</p>
<p>Now to the code. We start by declaring a <code>Vertex</code> structure that contains all of the items to appear in each vertex. Note that the coordinates are declared as points and the normal as a vector; the Ion math library distinguishes between the two types to make operations safer and more self-documenting.</p>
<p><div class="fragment"><div class="line"><span class="keyword">struct </span>Vertex {</div>
<div class="line">  ion::math::Point3f <a class="code" href="shapeutils_8cc.html#a0e34a3d7b94c100c4e0351e3c2f70123">position</a>;</div>
<div class="line">  ion::math::Point2f <a class="code" href="shapeutils_8cc.html#aa6fa7473a50aad75cf90965fb63fe3de">texture_coords</a>;</div>
<div class="line">  ion::math::Vector3f <a class="code" href="shapeutils_8cc.html#a1b8d96ad5ea7d8b704525d1efa3a3cb4">normal</a>;</div>
<div class="line">  <span class="keywordtype">float</span> offset_along_normal;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<p>Next we define a function that builds and returns a <a class="el" href="classion_1_1gfx_1_1_buffer_object.html" title="A BufferObject describes a generic array of data used, for example, to describe the vertices in a Sha...">gfx::BufferObject</a> storing the vertex data for the pyramid. The pyramid consists of four triangles, one for each side. (We don't bother with the base; feel free to add it yourself.) We have to define distinct vertices for all of the sides, since each has different normals and texture coordinates, not to mention that we are going to offset them individually. The function header is:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::BufferObjectPtr</a> BuildPyramidBufferObject() {</div>
</div><!-- fragment --></p>
<p>We begin the function by defining the five coordinate points of the pyramid for convenience:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">const</span> ion::math::Point3f apex(0.f, 1.f, 0.f);</div>
<div class="line">  <span class="keyword">const</span> ion::math::Point3f back_left(-1.f, -1.f, -1.f);</div>
<div class="line">  <span class="keyword">const</span> ion::math::Point3f back_right(1.f, -1.f, -1.f);</div>
<div class="line">  <span class="keyword">const</span> ion::math::Point3f front_left(-1.f, -1.f, 1.f);</div>
<div class="line">  <span class="keyword">const</span> ion::math::Point3f front_right(1.f, -1.f, 1.f);</div>
</div><!-- fragment --></p>
<p>Next we declare a local variable to hold the 12 vertices of the pyramid (4 sides, each with 3 vertices) and set the positions manually:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kVertexCount = 12U;  <span class="comment">// 3 vertices for each of 4 sides.</span></div>
<div class="line">  Vertex vertices[kVertexCount];</div>
<div class="line"></div>
<div class="line">  vertices[0].position = front_left;   <span class="comment">// Front side.</span></div>
<div class="line">  vertices[1].position = front_right;</div>
<div class="line">  vertices[2].position = apex;</div>
<div class="line">  vertices[3].position = front_right;  <span class="comment">// Right side.</span></div>
<div class="line">  vertices[4].position = back_right;</div>
<div class="line">  vertices[5].position = apex;</div>
<div class="line">  vertices[6].position = back_right;   <span class="comment">// Back side.</span></div>
<div class="line">  vertices[7].position = back_left;</div>
<div class="line">  vertices[8].position = apex;</div>
<div class="line">  vertices[9].position = back_left;    <span class="comment">// Left side.</span></div>
<div class="line">  vertices[10].position = front_left;</div>
<div class="line">  vertices[11].position = apex;</div>
</div><!-- fragment --></p>
<p>Next we loop over the four faces to compute surface normals and set the texture coordinates. It would be fairly easy to just set the surface normals to known values, but this way lets us demonstrate how to use some of Ion's math library:</p>
<p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> face = 0; face &lt; 4; ++face) {</div>
<div class="line">    Vertex&amp; v0 = vertices[3 * face + 0];</div>
<div class="line">    Vertex&amp; v1 = vertices[3 * face + 1];</div>
<div class="line">    Vertex&amp; v2 = vertices[3 * face + 2];</div>
<div class="line">    v0.normal = v1.normal = v2.normal = <a class="code" href="namespaceion_1_1math.html#aec69937a0111bcecf01fd9033fe9b1ba">ion::math::Cross</a>(</div>
<div class="line">        v1.position - v0.position, v2.position - v0.position);</div>
<div class="line">    v0.texture_coords.Set(0.f, 0.f);</div>
<div class="line">    v1.texture_coords.Set(1.f, 0.f);</div>
<div class="line">    v2.texture_coords.Set(.5f, 1.f);</div>
<div class="line">  }</div>
</div><!-- fragment --></p>
<p>Next we set the offsets in each of the vertices. Their values don't matter too much, so we just do something stupid and easy:</p>
<p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; kVertexCount; ++v)</div>
<div class="line">    vertices[v].offset_along_normal = .05f * static_cast&lt;float&gt;(1U + v % 2U);</div>
</div><!-- fragment --></p>
<p>Finally, we copy the vertex data into a <a class="el" href="classion_1_1base_1_1_data_container.html" title="The DataContainer class encapsulates arbitrary user data passed to Ion. ">base::DataContainer</a> and set that in a <a class="el" href="classion_1_1gfx_1_1_buffer_object.html" title="A BufferObject describes a generic array of data used, for example, to describe the vertices in a Sha...">gfx::BufferObject</a>, which we then return:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::base::DataContainerPtr</a> data_container =</div>
<div class="line">      ion::base::DataContainer::CreateAndCopy&lt;Vertex&gt;(</div>
<div class="line">          vertices, kVertexCount, <span class="keyword">true</span>, <a class="code" href="namespaceion_1_1base.html#a43c6663b5bdd5e5839eba0729b613c28">ion::base::AllocatorPtr</a>());</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::BufferObjectPtr</a> buffer_object(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_buffer_object.html">ion::gfx::BufferObject</a>);</div>
<div class="line">  buffer_object-&gt;SetData(data_container, <span class="keyword">sizeof</span>(vertices[0]), kVertexCount,</div>
<div class="line">                         <a class="code" href="classion_1_1gfx_1_1_buffer_object.html#a26069109c3d409bae3b77721f13cb592afb7fde3e14b50456b687bd115ba4aac0">ion::gfx::BufferObject::kStaticDraw</a>);</div>
<div class="line">  <span class="keywordflow">return</span> buffer_object;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>The next function builds and returns a <a class="el" href="classion_1_1gfx_1_1_attribute_array.html" title="An AttributeArray represents a collection of Attributes used to describe the vertices of a Shape...">gfx::AttributeArray</a> to represent the vertices stored in the <a class="el" href="classion_1_1gfx_1_1_buffer_object.html" title="A BufferObject describes a generic array of data used, for example, to describe the vertices in a Sha...">gfx::BufferObject</a> as attributes. Each <a class="el" href="classion_1_1gfx_1_1_attribute.html">gfx::Attribute</a> in the array defines a binding of vertex data in a <a class="el" href="classion_1_1gfx_1_1_buffer_object.html" title="A BufferObject describes a generic array of data used, for example, to describe the vertices in a Sha...">gfx::BufferObject</a> to attribute inputs to a vertex shader. For example, we want to bind the <code>position</code> field for the vertices to the <code>aVertex</code> attribute input to the vertex shader. The <a class="el" href="classion_1_1gfxutils_1_1_buffer_to_attribute_binder.html" title="BufferToAttributeBinder is a simple interface to insert a set of Attributes containing BufferObjectEl...">gfxutils::BufferToAttributeBinder</a> makes this process pretty easy - you just bind each of the registered attributes to the corresponding member field in a sample <code>Vertex:</code> </p>
<p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::AttributeArrayPtr</a> BuildPyramidAttributeArray(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::ShaderInputRegistryPtr</a>&amp; reg) {</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::BufferObjectPtr</a> buffer_object = BuildPyramidBufferObject();</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::AttributeArrayPtr</a> attribute_array(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_attribute_array.html">ion::gfx::AttributeArray</a>);</div>
<div class="line">  Vertex v;</div>
<div class="line">  <a class="code" href="classion_1_1gfxutils_1_1_buffer_to_attribute_binder.html">ion::gfxutils::BufferToAttributeBinder&lt;Vertex&gt;</a>(v)</div>
<div class="line">      .Bind(v.position, <span class="stringliteral">&quot;aVertex&quot;</span>)</div>
<div class="line">      .<a class="code" href="classion_1_1gfxutils_1_1_buffer_to_attribute_binder.html#ae7c2fd0d37473387cd6362a0e7fbb1dc">Bind</a>(v.texture_coords, <span class="stringliteral">&quot;aTexCoords&quot;</span>)</div>
<div class="line">      .<a class="code" href="classion_1_1gfxutils_1_1_buffer_to_attribute_binder.html#ae7c2fd0d37473387cd6362a0e7fbb1dc">Bind</a>(v.normal, <span class="stringliteral">&quot;aNormal&quot;</span>)</div>
<div class="line">      .<a class="code" href="classion_1_1gfxutils_1_1_buffer_to_attribute_binder.html#ae7c2fd0d37473387cd6362a0e7fbb1dc">Bind</a>(v.offset_along_normal, <span class="stringliteral">&quot;aOffsetAlongNormal&quot;</span>)</div>
<div class="line">      .<a class="code" href="classion_1_1gfxutils_1_1_buffer_to_attribute_binder.html#a459d15ae9f558167ba9beaa822cfb44e">Apply</a>(reg, attribute_array, buffer_object);</div>
<div class="line">  <span class="keywordflow">return</span> attribute_array;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>The next function builds and returns a <a class="el" href="classion_1_1gfx_1_1_index_buffer.html" title="An IndexBuffer is a type of BufferObject that contains the element indices of an array, e.g., a vertex index array. ">gfx::IndexBuffer</a> that stores vertex indices. We actually don't need to use indices for this very simple shape, as Ion will just use all of the vertices in order to create the pyramid triangles, but this shows how to create and use indices if you need to:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::IndexBufferPtr</a> BuildPyramidIndexBuffer() {</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::IndexBufferPtr</a> index_buffer(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_index_buffer.html">ion::gfx::IndexBuffer</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kIndexCount = 12U;</div>
<div class="line">  uint16 indices[kIndexCount];</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; kIndexCount; ++i)</div>
<div class="line">    indices[i] = static_cast&lt;uint16&gt;(i);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::base::DataContainerPtr</a> data_container =</div>
<div class="line">      ion::base::DataContainer::CreateAndCopy&lt;uint16&gt;(</div>
<div class="line">          indices, kIndexCount, <span class="keyword">true</span>, <a class="code" href="namespaceion_1_1base.html#a43c6663b5bdd5e5839eba0729b613c28">ion::base::AllocatorPtr</a>());</div>
<div class="line"></div>
<div class="line">  index_buffer-&gt;AddSpec(<a class="code" href="classion_1_1gfx_1_1_buffer_object.html#a6c1236c56d99c202b404c5f6166c85ada03af298af9cf61e8010e9e6459555e03">ion::gfx::BufferObject::kUnsignedShort</a>, 1, 0);</div>
<div class="line">  index_buffer-&gt;SetData(data_container, <span class="keyword">sizeof</span>(indices[0]), kIndexCount,</div>
<div class="line">                         <a class="code" href="classion_1_1gfx_1_1_buffer_object.html#a26069109c3d409bae3b77721f13cb592afb7fde3e14b50456b687bd115ba4aac0">ion::gfx::BufferObject::kStaticDraw</a>);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> index_buffer;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>This code is similar to creating the vertex buffer, except that we copy a simple array of index values into the <a class="el" href="classion_1_1base_1_1_data_container.html" title="The DataContainer class encapsulates arbitrary user data passed to Ion. ">base::DataContainer</a>. One other difference is the explicit call to <a class="el" href="classion_1_1gfx_1_1_buffer_object.html#a0c53b2ca50f3b52896a7b8c609401fbd" title="Describes an element of an arbitrary datatype to the BufferObject. ">gfx::BufferObject::AddSpec()</a>, which was done for us in the vertex buffer case by the <a class="el" href="classion_1_1gfxutils_1_1_buffer_to_attribute_binder.html" title="BufferToAttributeBinder is a simple interface to insert a set of Attributes containing BufferObjectEl...">gfxutils::BufferToAttributeBinder</a> class.</p>
<p>Creating the shape is relatively easy, now that we have the above functions:</p>
<p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::ShapePtr</a> BuildPyramidShape(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::ShaderInputRegistryPtr</a>&amp; reg) {</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::ShapePtr</a> shape(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_shape.html">ion::gfx::Shape</a>);</div>
<div class="line">  shape-&gt;SetLabel(<span class="stringliteral">&quot;Pyramid&quot;</span>);</div>
<div class="line">  shape-&gt;SetPrimitiveType(<a class="code" href="classion_1_1gfx_1_1_shape.html#ad5feef133735b37165541c3bb11e5012ae0ac637ca5732ee25983c372b7316b88">ion::gfx::Shape::kTriangles</a>);</div>
<div class="line">  shape-&gt;SetAttributeArray(BuildPyramidAttributeArray(reg));</div>
<div class="line">  shape-&gt;SetIndexBuffer(BuildPyramidIndexBuffer());</div>
<div class="line">  <span class="keywordflow">return</span> shape;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>All that is left to do is to update the <code>BuildGraph()</code> function to set up the pyramid shape. The first modification is to set the back-face culling state to false in the <a class="el" href="classion_1_1gfx_1_1_state_table.html" title="A StateTable represents a collection of graphical state items that affect OpenGL rendering. ">gfx::StateTable</a>, which will allow all four pyramid faces to be displayed. Since this flag is disabled by default, we could instead just remove the line that sets it:</p>
<p><div class="fragment"><div class="line">  state_table-&gt;Enable(<a class="code" href="classion_1_1gfx_1_1_state_table.html#ae6f345fc251ac53d5797d6300859d665a3cba54f28abf33e3b45e643c00657d3b">ion::gfx::StateTable::kCullFace</a>, <span class="keyword">false</span>);</div>
</div><!-- fragment --></p>
<p>We no longer need to set up the <code>uWaveFrequency</code> uniform, but we do need to register the custom vertex attribute:</p>
<p><div class="fragment"><div class="line">  reg-&gt;Add(<a class="code" href="struction_1_1gfx_1_1_shader_input_registry_1_1_spec.html">ion::gfx::ShaderInputRegistry::AttributeSpec</a>(</div>
<div class="line">      <span class="stringliteral">&quot;aOffsetAlongNormal&quot;</span>, <a class="code" href="namespaceion_1_1gfx.html#ad9f0be4740e4ec6c2221726138cd69f2a67b53e83d15820215144663e1d0d7d31">ion::gfx::kBufferObjectElementAttribute</a>,</div>
<div class="line">      <span class="stringliteral">&quot;Offset of each vertex along its surface normal vector&quot;</span>));</div>
</div><!-- fragment --></p>
<p>Adding the shape is easy:</p>
<p><div class="fragment"><div class="line">  root-&gt;AddShape(BuildPyramidShape(reg));</div>
</div><!-- fragment --></p>
<p>This example also uses some Ion math utilities to set up the projection and modelview matrix values to create a different view:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classion_1_1math_1_1_matrix.html">ion::math::Matrix4f</a> proj =</div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#a301d6add45d8baa6543f4bec024aab68">ion::math::PerspectiveMatrixFromView</a>(ion::math::Anglef::FromDegrees(60.f),</div>
<div class="line">                                           1.f, .1f, 10.f);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classion_1_1math_1_1_matrix.html">ion::math::Matrix4f</a> view =</div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#a6bf08090efdf1c1de1f8e97d8606dc5b">ion::math::LookAtMatrixFromCenter</a>(ion::math::Point3f(3.f, 2.f, 5.f),</div>
<div class="line">                                        ion::math::Point3f::Zero(),</div>
<div class="line">                                        ion::math::Vector3f::AxisY());</div>
</div><!-- fragment --></p>
<hr/>
 <div class="image">
<img src="hierarchy_thumbnail.png"  style="float: right; width: 180px; margin-left: 20px" alt="Hierarchy Thumbnail"/>
</div>
<h1><a class="anchor" id="UG_Hierarchy_Example"></a>
Example 5: Creating a Node Hierarchy</h1>
<p>All of the previous examples used a single <a class="el" href="classion_1_1gfx_1_1_node.html" title="A Node instance represents a node in a scene graph. ">gfx::Node</a> containing a single <a class="el" href="classion_1_1gfx_1_1_shape.html" title="A Shape object represents a shape (vertices + indices) to draw. ">gfx::Shape</a>, but real-world applications typically need more than that. Ion provides the flexibility to structure your scenes to balance ease of construction and rendering performance.</p>
<p>For example, if you wish to render a collection of different primitive objects that all share the same state (shaders, uniform settings, global state), you can just add a <a class="el" href="classion_1_1gfx_1_1_shape.html" title="A Shape object represents a shape (vertices + indices) to draw. ">gfx::Shape</a> for each of them to a single <a class="el" href="classion_1_1gfx_1_1_node.html" title="A Node instance represents a node in a scene graph. ">gfx::Node</a>. But if the objects do not share the same state, you need to use multiple <a class="el" href="classion_1_1gfx_1_1_node.html" title="A Node instance represents a node in a scene graph. ">gfx::Node</a> instances. If you completely define the proper state for each node individually, you can just call <a class="el" href="classion_1_1gfx_1_1_renderer.html#ac13a3bd2eb6fb1854ff2b1550c40dc54" title="Draws the scene rooted by the given node into the currently bound framebuffer. ">gfx::Renderer::DrawScene()</a> for each of them in your application's rendering loop. However, if the nodes share any common state, it will usually be more efficient to create a hierarchy in which the nodes can share some of the state. The example in this section shows how to do that (source code in <code><a class="el" href="hierarchy_8cc.html">examples/hierarchy.cc</a></code>).</p>
<p>The scene is this example consists of three nodes, pictured in yellow in the below diagram. <code>Node2</code> and <code>Node3</code> are children of <code>Node1</code>, meaning that they will inherit state from it. All of the nodes have some state associated with them: state tables, shaders, and uniform values. Each node also has one shape (magenta) that illustrate the effects of the state present at the node.</p>
<p><div class="diagraph">
<img src="/usr/local/google/home/cdonner/working/ggion/ion/ion/doxygen/html/dia_hierarchy.png" />
</div>
</p>
<p>Here are some rules about how state is inherited through a scene:</p>
<ul>
<li>A <a class="el" href="classion_1_1gfx_1_1_shader_program.html" title="A ShaderProgram represents an OpenGL shader program that can be applied to shapes. ">gfx::ShaderProgram</a> in a node is used for that node and all of its descendents that do not have their own shaders. A shader program in a descendent overrides an inherited shader for that descendent and all of its descendents. In the example, the shader program in <code>Node1</code> is used for both <code>Node1</code> and <code>Node2</code>. The shader program in <code>Node3</code> is used for <code>Node3</code> and would also be used for any program-less children of <code>Node3</code>.</li>
</ul>
<ul>
<li>A <a class="el" href="classion_1_1gfx_1_1_state_table.html" title="A StateTable represents a collection of graphical state items that affect OpenGL rendering. ">gfx::StateTable</a> sets the global state for a node and all of its descendents. However, there are lots of values in a StateTable, and each can be set independently. Only the values that are set explicitly in a StateTable instance will modify the state during rendering. For example, if the only change you make to a newly-constructed StateTable is to enable depth testing, that is the only change it will make to the state. In the example, whatever state is set by the table in <code>Node1</code> will be present in all three nodes, whereas the state set by the table in <code>Node2</code> will be present only for <code>Node2</code>.</li>
</ul>
<ul>
<li><a class="el" href="classion_1_1gfx_1_1_uniform.html" title="A Uniform instance represents a uniform shader argument. ">gfx::Uniform</a> values are a bit more complex. If a node inherits its shader program from a parent or other ancestor, it also inherits all uniform values. If the child node defines any of the same uniforms, those values override those in the parent for the child and any of its descendents that inherit the shader program. Any node that has shapes in it <em>must</em> define or inherit values for all uniforms used by the shader program applied to that node.</li>
</ul>
<ul>
<li>Almost all uniform values override inherited uniform values. The notable exception to this rule is the <code>uModelviewMatrix</code> uniform, which is defined in the global registry. This uniform <em>accumulates</em> its value by multiplying the inherited matrix and the new one. This feature is extremely important, as it allows you to easily create transformation hierarchies. (Note that you can define any new uniform to accumulate its values in any way you choose by specifying a <a class="el" href="struction_1_1gfx_1_1_shader_input_registry_1_1_combine_function.html" title="This type defines a function that is used to combine values for two instances of a registered shader ...">gfx::ShaderInputRegistry::CombineFunction</a> when you create a <a class="el" href="classion_1_1gfx_1_1_shader_input_registry.html#ac0343455043934c00898cad8f018704f">gfx::ShaderInputRegistry::UniformSpec</a>.)</li>
</ul>
<p>The vertex shader for <code>Node1</code> in the example applies a gradient from top to bottom (as in <a class="el" href="_users_guide.html#UG_Shaders_Example">Example 2: Specifying Shaders</a>) and passes the surface normal to the fragment shader:</p>
<p><div class="fragment"><div class="line">    <span class="stringliteral">&quot;void main(void) {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vNormal = aNormal;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vColor = mix(uBottomColor, uTopColor, .5 * (1. + aVertex.y));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  gl_Position = uProjectionMatrix * uModelviewMatrix *\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;      vec4(aVertex, 1.);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;}\n&quot;</span>);</div>
</div><!-- fragment --></p>
<p><code>Node1's</code> fragment shader just applies the same basic lighting as before:</p>
<p><div class="fragment"><div class="line">    <span class="stringliteral">&quot;void main(void) {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vec3 normal = normalize(vNormal);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vec3 dir_to_light = normalize(vec3(1., 4., 8.));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  float intensity = min(1., abs(dot(dir_to_light, normal)));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  gl_FragColor = intensity * vColor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;}\n&quot;</span>);</div>
</div><!-- fragment --></p>
<p><code>Node3's</code> vertex shader just updates the position and passes the surface normal to the fragment shader. The fragment shader compares the surface normal and the <code>uOpenDirection</code> vector uniform and discards the fragment if they are similar enough:</p>
<p><div class="fragment"><div class="line">    <span class="stringliteral">&quot;uniform vec3 uOpenDirection;\n&quot;</span></div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="stringliteral">&quot;void main(void) {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vec3 normal = normalize(vNormal);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  if (dot(vNormal, uOpenDirection) &gt; .9)\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;    discard;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  vec3 dir_to_light = normalize(vec3(1., 1., 2.));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  float intensity = min(1., abs(dot(dir_to_light, normal)));\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  gl_FragColor = intensity * uBaseColor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;}\n&quot;</span>);</div>
</div><!-- fragment --></p>
<p>The code contains a function to build each of the three nodes individually. Most of the code is similar to that of previous examples, so we will highlight only the important differences.</p>
<p>In the <code>BuildNode1()</code> function, we create a sphere shape using the <a class="el" href="namespaceion_1_1gfxutils.html#a88d391fb7293c2321bbd4d998856a98b" title="Builds and returns a Shape representing an axis-aligned ellipsoid. ">gfxutils::BuildEllipsoidShape()</a> function and add it to the node. Then we set up a <a class="el" href="classion_1_1gfx_1_1_state_table.html" title="A StateTable represents a collection of graphical state items that affect OpenGL rendering. ">gfx::StateTable</a> and <a class="el" href="classion_1_1gfx_1_1_shader_program.html" title="A ShaderProgram represents an OpenGL shader program that can be applied to shapes. ">gfx::ShaderProgram</a> as before. We need to add all four of the uniforms required by the shader program to the node:</p>
<p><div class="fragment"><div class="line">  node1-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(<span class="stringliteral">&quot;uProjectionMatrix&quot;</span>, proj));</div>
<div class="line">  node1-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(<span class="stringliteral">&quot;uModelviewMatrix&quot;</span>, view));</div>
<div class="line">  node1-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uTopColor&quot;</span>, ion::math::Vector4f(1.f, .2f, .2f, 1.f)));</div>
<div class="line">  node1-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uBottomColor&quot;</span>, ion::math::Vector4f(.2f, 1.f, 1.f, 1.f)));</div>
</div><!-- fragment --></p>
<p>In the <code>BuildNode2()</code> function, we create and add a box shape using <a class="el" href="namespaceion_1_1gfxutils.html#a697686ec86b73d8f15f05794764292c6" title="Builds and returns a Shape representing an axis-aligned box. ">gfxutils::BuildBoxShape()</a> and also add a new StateTable that culls front faces instead of back faces. The rest of the state is inherited from <code>Node1</code>. Note that we use the default constructor for <a class="el" href="classion_1_1gfx_1_1_state_table.html" title="A StateTable represents a collection of graphical state items that affect OpenGL rendering. ">gfx::StateTable</a> that does not take the window size parameters. They are not needed because we are not setting the viewport (or scissor box).</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::StateTablePtr</a> state_table(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_state_table.html">ion::gfx::StateTable</a>);</div>
<div class="line">  state_table-&gt;SetCullFaceMode(<a class="code" href="classion_1_1gfx_1_1_state_table.html#a404fb458a371dac7d2b5a1bcad075a28a6bf9675883dc70acf5a8c31fd6b2c9c2">ion::gfx::StateTable::kCullFront</a>);</div>
<div class="line">  node2-&gt;SetStateTable(state_table);</div>
</div><!-- fragment --></p>
<p>Then we set new values for the color and model-view uniforms. Note that we do not specify a new value for the <code>uProjectionMatrix</code> uniform, so that is inherited. Also note that the value for <code>uModelviewMatrix</code> is accumulated with the inherited value, which results in an extra translation applied to the box to position it at the lower left.</p>
<p><div class="fragment"><div class="line">  node2-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uTopColor&quot;</span>, ion::math::Vector4f(.9f, .9f, .2f, 1.f)));</div>
<div class="line">  node2-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uBottomColor&quot;</span>, ion::math::Vector4f(.9f, .1f, .9f, 1.f)));</div>
<div class="line">  node2-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uModelviewMatrix&quot;</span>,</div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#a4aef694ac9124b3bdd70ea1f8d431970">ion::math::TranslationMatrix</a>(ion::math::Point3f(-2.f, -3.f, 0.f))));</div>
</div><!-- fragment --></p>
<p>In <code>BuildNode3()</code>, we add a cylinder shape with <a class="el" href="namespaceion_1_1gfxutils.html#a90b0e45cabf5a0093f2f7486dcb0425a" title="Builds and returns a Shape representing an axis-aligned cylinder. ">gfxutils::BuildCylinderShape()</a>. Then we set up and add a new registry and shader program to override the one in <code>Node1:</code> </p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::ShaderInputRegistryPtr</a> reg(<span class="keyword">new</span> <a class="code" href="classion_1_1gfx_1_1_shader_input_registry.html">ion::gfx::ShaderInputRegistry</a>);</div>
<div class="line">  reg-&gt;IncludeGlobalRegistry();</div>
<div class="line">  reg-&gt;Add(<a class="code" href="struction_1_1gfx_1_1_shader_input_registry_1_1_spec.html">ion::gfx::ShaderInputRegistry::UniformSpec</a>(</div>
<div class="line">      <span class="stringliteral">&quot;uOpenDirection&quot;</span>, <a class="code" href="namespaceion_1_1gfx.html#a08bbfe864fd7c473f2873534535a9643a68f812bcd8299939236e4cf49ed1806d">ion::gfx::kFloatVector3Uniform</a>,</div>
<div class="line">      <span class="stringliteral">&quot;Surface normal direction near cut-out&quot;</span>));</div>
<div class="line">  node3-&gt;SetShaderProgram(</div>
<div class="line">      <a class="code" href="classion_1_1gfx_1_1_shader_program.html#a0c48ae4682ac587930ab2e604de1a588">ion::gfx::ShaderProgram::BuildFromStrings</a>(</div>
<div class="line">          <span class="stringliteral">&quot;Node3 shader&quot;</span>, reg, kNode3VertexShaderString,</div>
<div class="line">          kNode3FragmentShaderString, <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::base::AllocatorPtr</a>()));</div>
</div><!-- fragment --></p>
<p>We then set values for uniforms. Again, we do not have to set a value for the <code>uProjectionMatrix</code> uniform, as it is inherited from <code>Node1</code>, even though we are using a different shader. This is possible because the shaders in both <code>Node1</code> and <code>Node3</code> include the global registry, which defines that uniform.</p>
<p><div class="fragment"><div class="line">  node3-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uModelviewMatrix&quot;</span>,</div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#a4aef694ac9124b3bdd70ea1f8d431970">ion::math::TranslationMatrix</a>(ion::math::Point3f(2.f, -3.f, 0.f))));</div>
<div class="line">  node3-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uBaseColor&quot;</span>, ion::math::Vector4f(.9f, .9f, .7f, 1.f)));</div>
<div class="line">  node3-&gt;AddUniform(reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uOpenDirection&quot;</span>, ion::math::Vector3f::AxisZ()));</div>
</div><!-- fragment --></p>
<p>Finally, we put all the pieces together in the <code>BuildGraph()</code> function:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::NodePtr</a> BuildGraph(<span class="keywordtype">int</span> window_width, <span class="keywordtype">int</span> window_height) {</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::NodePtr</a> node1 = BuildNode1(window_width, window_height);</div>
<div class="line">  node1-&gt;AddChild(BuildNode2(node1-&gt;GetShaderProgram()-&gt;GetRegistry()));</div>
<div class="line">  node1-&gt;AddChild(BuildNode3());</div>
<div class="line">  <span class="keywordflow">return</span> node1;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<hr/>
 <h1><a class="anchor" id="UG_Multipass_Example"></a>
Example 6: Using Framebuffer Objects for Multipass Rendering</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Write this!</dd></dl>
<hr/>
 <h1><a class="anchor" id="UG_Mapped_Example"></a>
Example 7: Using Mapped Buffers</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Write this!</dd></dl>
<hr/>
 <h1><a class="anchor" id="UG_Sharing_Example"></a>
Example 8: Sharing Objects</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Write this!</dd></dl>
<hr/>
 <div class="image">
<img src="text_thumbnail.png"  style="float: right; width: 180px; margin-left: 20px" alt="Text Thumbnail"/>
</div>
<h1><a class="anchor" id="UG_Text_Example"></a>
Example 9: Adding Text</h1>
<p>Earlier we called <a class="el" href="_users_guide.html#UG_Rectangle_Example">Example 1: Drawing a Rectangle</a> the "hello world" program for Ion. This example shows how you can really show the words as text in your application. The source code is in <code><a class="el" href="text_8cc.html">examples/text.cc</a></code>.</p>
<p>The Ion text library draws text as texture-mapped geometry. Specifically, it uses signed-distance field (SDF) textures to represent the character glyphs, along with shaders that display those glyphs nicely. The library makes it easy to display basic text and also makes it possible to create more complex representations. The main text classes are:</p>
<ul>
<li><a class="el" href="classion_1_1text_1_1_font.html" title="Font is a base class for implementation-specific representations of fonts. ">text::Font</a> represents a specific font, specified by name, size in pixels, and an SDF padding value. For best results you should try to use a font size that is relatively close to the the size at which the text will be displayed. Of course, larger sizes consume more resources, so be careful. The SDF padding value is used to allow the signed distances to fall off gradually outside the glyph edges, rather than being cut off. Values between 4 and 8 pixels are typical.</li>
</ul>
<ul>
<li>A <a class="el" href="classion_1_1text_1_1_font_image.html" title="A FontImage contains image and texture coordinate information used to render font glyphs...">text::FontImage</a> stores one or more <a class="el" href="classion_1_1gfx_1_1_texture.html" title="A Texture object represents the image data and mipmaps associated with a single texture. ">gfx::Texture</a> instances that are used to display the glyphs of a <a class="el" href="classion_1_1text_1_1_font.html" title="Font is a base class for implementation-specific representations of fonts. ">text::Font</a>. The <a class="el" href="classion_1_1text_1_1_static_font_image.html" title="StaticFontImage is a derived FontImage that contains a single ImageData instance that is created by t...">text::StaticFontImage</a> class stores all glyphs in a single texture, so it is useful when the full set of glyphs to be used is known ahead of time and the cost of setting up a single image containing them is not too great. The <a class="el" href="classion_1_1text_1_1_dynamic_font_image.html" title="DynamicFontImage is a derived FontImage that may contain any number of ImageData instances. ">text::DynamicFontImage</a> class, on the other hand, stores any number of fixed-size textures, each representing some subset of glyphs. It allows you to incrementally build the textures as you discover which glyphs are required. The cost of using dynamic images is that there can be a lot of glyph duplication: if each text string to display requires a single texture, then the same glyph may appear in multiple textures.</li>
</ul>
<ul>
<li>The <a class="el" href="classion_1_1text_1_1_font_manager.html" title="The FontManager provides the main interface for fonts used to create text strings to render...">text::FontManager</a> class provides a way to cache <a class="el" href="classion_1_1text_1_1_font.html" title="Font is a base class for implementation-specific representations of fonts. ">text::Font</a> and <a class="el" href="classion_1_1text_1_1_font_image.html" title="A FontImage contains image and texture coordinate information used to render font glyphs...">text::FontImage</a> instances so that different parts of your application can share them.</li>
</ul>
<ul>
<li>A <a class="el" href="classion_1_1text_1_1_layout.html" title="A Layout instance specifies how glyphs are arranged to form text. ">text::Layout</a> specifies how character glyphs are arranged to form text. It is a very flexible class: each glyph can be mapped onto any 3D quadrilateral. You can use the <a class="el" href="classion_1_1text_1_1_font.html#ab7941b94320566c59d87f31445365cca" title="Creates a layout as specified by options for a given single- or multi- line string text...">text::Font::BuildLayout()</a> method to create a layout for conventional straight-line, left-to-right text in the XY-plane, with options for alignment, spacing, and so on. (See the code below for examples.)</li>
</ul>
<ul>
<li>The <a class="el" href="classion_1_1text_1_1_builder.html" title="Builder is an abstract base class for building graphics objects used to render text. ">text::Builder</a> class is a convenience base class that does most of the work of setting up a <a class="el" href="classion_1_1gfx_1_1_node.html" title="A Node instance represents a node in a scene graph. ">gfx::Node</a> to representing a text object. You give it a <a class="el" href="classion_1_1text_1_1_font_image.html" title="A FontImage contains image and texture coordinate information used to render font glyphs...">text::FontImage</a> when you create an instance, then pass a <a class="el" href="classion_1_1text_1_1_layout.html" title="A Layout instance specifies how glyphs are arranged to form text. ">text::Layout</a> to the <a class="el" href="classion_1_1text_1_1_builder.html#ae71199cdf24fd8796399ebbaacedb738" title="Builds an Ion Node representing the text string defined by a Layout, using the FontImage passed to th...">text::Builder::Build()</a> function. The resulting node will contain everything needed to draw text: a shape, shader program, uniforms, and state table. The derived <a class="el" href="classion_1_1text_1_1_basic_builder.html" title="BasicBuilder is a derived Builder class that uses a very basic shader to render text. ">text::BasicBuilder</a> class creates text with a single color, while the <a class="el" href="classion_1_1text_1_1_outline_builder.html" title="OutlineBuilder is a derived Builder class that can render text with outlines. ">text::OutlineBuilder</a> class (used in the example below) also adds customizable outlines. Both classes allow you to modify the uniforms to customize the text display after the text node has been built. They also allow you to rebuild text using a different layout, reusing existing objects as much as possible.</li>
</ul>
<p>We need these additional header files:</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="fontimage_8h.html">ion/text/fontimage.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="freetypefont_8h.html">ion/text/freetypefont.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="layout_8h.html">ion/text/layout.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="outlinebuilder_8h.html">ion/text/outlinebuilder.h</a>&quot;</span></div>
</div><!-- fragment --></p>
<p>The data for the font is stored in a header file created from a public-domain TrueType font. This is typically not the way you want to load font data, but it makes the example code simple and does not require any platform-specific file handling:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> kFontData[] = {</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="fontdata_8h.html">./fontdata.h</a>&quot;</span></div>
<div class="line">};</div>
</div><!-- fragment --></p>
<p>The <code>CreateFont()</code> function creates and returns a <a class="el" href="classion_1_1text_1_1_font.html" title="Font is a base class for implementation-specific representations of fonts. ">text::Font</a> built from the data. We use a font size of 64 pixels, which is large enough to make the text look reasonably good:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::text::FontPtr</a> CreateFont() {</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> kFontName[] = <span class="stringliteral">&quot;ExampleFont&quot;</span>;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kFontSizeInPixels = 64U;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kSdfPadding = 8U;</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::text::FontPtr</a> font(<span class="keyword">new</span> <a class="code" href="classion_1_1text_1_1_free_type_font.html">ion::text::FreeTypeFont</a>(</div>
<div class="line">      kFontName, kFontSizeInPixels, kSdfPadding, kFontData, <span class="keyword">sizeof</span>(kFontData)));</div>
<div class="line">  <span class="keywordflow">return</span> font;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>The example builds two text nodes to display. The first one says "Hello,
World!" on two lines. It is created by this function:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::NodePtr</a> BuildTextNode(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::text::FontImagePtr</a>&amp; font_image) {</div>
</div><!-- fragment --></p>
<p>First, we set up a <a class="el" href="struction_1_1text_1_1_layout_options.html" title="This struct defines parameters affecting layout of a single text string when passed to BuildLayout()...">text::LayoutOptions</a> instance that specifies how we want the text to be laid out. We set the size to be 0 units wide and 2 units high. This means that the text width will be computed proportionally to match the size-2 height. We specify that the text is to be aligned about the center in both dimensions, and the spacing between the lines is to be 1.5 times the maximum font glyph height. Then we build the <a class="el" href="classion_1_1text_1_1_layout.html" title="A Layout instance specifies how glyphs are arranged to form text. ">text::Layout</a> using the font, the desired string, and the options:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classion_1_1text_1_1_layout.html">ion::text::Layout</a> layout =</div>
<div class="line">      font_image-&gt;GetFont()-&gt;BuildLayout(<span class="stringliteral">&quot;Hello,\nWorld!&quot;</span>, options);</div>
</div><!-- fragment --></p>
<p>Then we set up a <a class="el" href="classion_1_1text_1_1_outline_builder.html" title="OutlineBuilder is a derived Builder class that can render text with outlines. ">text::OutlineBuilder</a> to build the text node. We specify some color and outlining options to make things look the way we want and return the resulting node:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::text::OutlineBuilderPtr</a> outline_builder(<span class="keyword">new</span> <a class="code" href="classion_1_1text_1_1_outline_builder.html">ion::text::OutlineBuilder</a>(</div>
<div class="line">      font_image, <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfxutils::ShaderManagerPtr</a>(),</div>
<div class="line">      <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::base::AllocatorPtr</a>()));</div>
<div class="line">  outline_builder-&gt;Build(layout, <a class="code" href="classion_1_1gfx_1_1_buffer_object.html#a26069109c3d409bae3b77721f13cb592a9f64b0938cfc761d049a8239f5d963f7">ion::gfx::BufferObject::kStreamDraw</a>);</div>
<div class="line">  outline_builder-&gt;SetTextColor(ion::math::Vector4f(1.f, 1.f, .4f, 1.f));</div>
<div class="line">  outline_builder-&gt;SetOutlineColor(ion::math::Vector4f(.1f, .1f, .1f, 1.f));</div>
<div class="line">  outline_builder-&gt;SetHalfSmoothWidth(2.f);</div>
<div class="line">  outline_builder-&gt;SetOutlineWidth(6.f);</div>
<div class="line">  <span class="keywordflow">return</span> outline_builder-&gt;GetNode();</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>The other text node in our example will be forced to be aligned with the screen. We set it up the same way, but with different size, alignment, and colors. We also set the target point to offset the text a little bit from the left side of the window:</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::NodePtr</a> BuildScreenAlignedTextNode(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::text::FontImagePtr</a>&amp; font_image) {</div>
<div class="line">  <a class="code" href="struction_1_1text_1_1_layout_options.html">ion::text::LayoutOptions</a> options;</div>
<div class="line">  options.<a class="code" href="struction_1_1text_1_1_layout_options.html#aba4e1b0ac1a95fa0c2ae6777aadd81fc">target_point</a>.Set(0.1f, 0.f);</div>
<div class="line">  options.<a class="code" href="struction_1_1text_1_1_layout_options.html#a005363c093dc62b988af7c4ea7d76da5">target_size</a>.Set(0.f, .06f);</div>
<div class="line">  options.<a class="code" href="struction_1_1text_1_1_layout_options.html#a662847f65b27b7363691e2ad2e3e0a74">horizontal_alignment</a> = <a class="code" href="namespaceion_1_1text.html#a5102ec2b5d158b576de4bff04e6a044ca26a0f52788c16a6f556d859d5ba58e99">ion::text::kAlignLeft</a>;</div>
<div class="line">  options.<a class="code" href="struction_1_1text_1_1_layout_options.html#a1f20714a523bcfa1cc9f384562c8b61c">vertical_alignment</a> = <a class="code" href="namespaceion_1_1text.html#a81a7b40d701fcee40fe1ee9f1b663767a6f2b45d304c761c2c75706c352d6a421">ion::text::kAlignBottom</a>;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classion_1_1text_1_1_layout.html">ion::text::Layout</a> layout =</div>
<div class="line">      font_image-&gt;GetFont()-&gt;BuildLayout(<span class="stringliteral">&quot;Screen-Aligned text&quot;</span>, options);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::text::OutlineBuilderPtr</a> outline_builder(<span class="keyword">new</span> <a class="code" href="classion_1_1text_1_1_outline_builder.html">ion::text::OutlineBuilder</a>(</div>
<div class="line">      font_image, <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfxutils::ShaderManagerPtr</a>(),</div>
<div class="line">      <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::base::AllocatorPtr</a>()));</div>
<div class="line">  outline_builder-&gt;Build(layout, <a class="code" href="classion_1_1gfx_1_1_buffer_object.html#a26069109c3d409bae3b77721f13cb592a9f64b0938cfc761d049a8239f5d963f7">ion::gfx::BufferObject::kStreamDraw</a>);</div>
<div class="line">  outline_builder-&gt;SetTextColor(ion::math::Vector4f(1.f, .8f, .8f, 1.f));</div>
<div class="line">  outline_builder-&gt;SetOutlineColor(ion::math::Vector4f(.2f, .2f, .2f, 1.f));</div>
<div class="line">  outline_builder-&gt;SetHalfSmoothWidth(2.f);</div>
<div class="line">  outline_builder-&gt;SetOutlineWidth(6.f);</div>
<div class="line">  <span class="keywordflow">return</span> outline_builder-&gt;GetNode();</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>In the BuildGraph() function we build a root node and add the two text nodes to it as children. The shader created by the <a class="el" href="classion_1_1text_1_1_outline_builder.html" title="OutlineBuilder is a derived Builder class that can render text with outlines. ">text::OutlineBuilder</a> requires the <code>uViewportSize</code> uniform (defined in the global registry) to be specified so that it can figure out how big font pixels are. We create a variable to store the window size:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">const</span> ion::math::Vector2i window_size(window_width, window_height);</div>
</div><!-- fragment --></p>
<p>And we use this when setting up the viewport in the state table:</p>
<p><div class="fragment"><div class="line">  state_table-&gt;SetViewport(</div>
<div class="line">      ion::math::Range2i::BuildWithSize(ion::math::Point2i(0, 0), window_size));</div>
</div><!-- fragment --></p>
<p>And then we use it to set the <code>uViewportSize</code> uniform in the root node. We could store this uniform in both of the text nodes, where it is really needed, but this is more convenient and efficient:</p>
<p><div class="fragment"><div class="line">  root-&gt;AddUniform(global_reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uViewportSize&quot;</span>, window_size));</div>
</div><!-- fragment --></p>
<p>Next we create a <a class="el" href="classion_1_1text_1_1_font.html" title="Font is a base class for implementation-specific representations of fonts. ">text::Font</a> and <a class="el" href="classion_1_1text_1_1_dynamic_font_image.html" title="DynamicFontImage is a derived FontImage that may contain any number of ImageData instances. ">text::DynamicFontImage</a>:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::text::FontPtr</a> font = CreateFont();</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> kFontImageSize = 256U;</div>
<div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::text::DynamicFontImagePtr</a> font_image(</div>
<div class="line">      <span class="keyword">new</span> <a class="code" href="classion_1_1text_1_1_dynamic_font_image.html">ion::text::DynamicFontImage</a>(font, kFontImageSize));</div>
</div><!-- fragment --></p>
<p>We next build and add the text node for the "Hello, World!" text. We set up an arbitrary perspective view for this text:</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::NodePtr</a> text_node = BuildTextNode(font_image);</div>
<div class="line">  text_node-&gt;AddUniform(global_reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uProjectionMatrix&quot;</span>,</div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#a301d6add45d8baa6543f4bec024aab68">ion::math::PerspectiveMatrixFromView</a>(ion::math::Anglef::FromDegrees(60.f),</div>
<div class="line">                                           1.f, .1f, 10.f)));</div>
<div class="line">  text_node-&gt;AddUniform(global_reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uModelviewMatrix&quot;</span>,</div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#a6bf08090efdf1c1de1f8e97d8606dc5b">ion::math::LookAtMatrixFromCenter</a>(ion::math::Point3f(2.f, 2.f, 4.f),</div>
<div class="line">                                        ion::math::Point3f::Zero(),</div>
<div class="line">                                        ion::math::Vector3f::AxisY())));</div>
<div class="line">  root-&gt;AddChild(text_node);</div>
</div><!-- fragment --></p>
<p>Then we do the same for the screen-aligned text. Note that we set up an orthographic projection matrix to make the text (which is in the XY-plane) remain parallel to the screen.</p>
<p><div class="fragment"><div class="line">  <a class="code" href="classion_1_1base_1_1_shared_ptr.html">ion::gfx::NodePtr</a> aligned_text_node = BuildScreenAlignedTextNode(font_image);</div>
<div class="line">  aligned_text_node-&gt;AddUniform(global_reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uProjectionMatrix&quot;</span>,</div>
<div class="line">      <a class="code" href="namespaceion_1_1math.html#a1785c55a90bdd53ba051de3b7bacaf3e">ion::math::OrthographicMatrixFromFrustum</a>(0.f, 1.f, 0.f, 1.f, -1.f, 1.f)));</div>
<div class="line">  aligned_text_node-&gt;AddUniform(global_reg-&gt;Create&lt;<a class="code" href="classion_1_1gfx_1_1_uniform.html">ion::gfx::Uniform</a>&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;uModelviewMatrix&quot;</span>, <a class="code" href="classion_1_1math_1_1_matrix.html#a37787a14eee310637ccb297f18bd9c6c">ion::math::Matrix4f::Identity</a>()));</div>
<div class="line">  root-&gt;AddChild(aligned_text_node);</div>
</div><!-- fragment --></p>
<p>In a real, interactive application, you may want to keep the <a class="el" href="classion_1_1text_1_1_builder.html" title="Builder is an abstract base class for building graphics objects used to render text. ">text::Builder</a> instance around to be able to make modifications to the text, such as changing its color or changing what string is displayed.</p>
<hr/>
 <h1><a class="anchor" id="UG_DevelopmentTools"></a>
Development Tools</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Write this!</dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
