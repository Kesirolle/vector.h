<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Ion: ion::base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ion
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceion_1_1base.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ion::base Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classion_1_1base_1_1_enum_helper.html" title="}; static const char* kStrings[] = { &quot;Value1&quot;, &quot;Value2&quot;, &quot;Value3&quot; }; return EnumData&lt;Values&gt;(IndexMap...">EnumHelper</a> instantiations. These must be in the <a class="el" href="namespaceion_1_1base.html" title="EnumHelper instantiations. These must be in the ion::base namespace. ">ion::base</a> namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceion_1_1base_1_1_alloc_tracker"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base_1_1_alloc_tracker.html">AllocTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceion_1_1base_1_1internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceion_1_1base_1_1internal__variant__utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base_1_1internal__variant__utils.html">internal_variant_utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceion_1_1base_1_1logging__internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base_1_1logging__internal.html">logging_internal</a></td></tr>
<tr class="memdesc:namespaceion_1_1base_1_1logging__internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal logging implementation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_allocatable.html">Allocatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_allocatable.html" title="Allocatable is an abstract base class for classes whose memory is managed by an Allocator. ">Allocatable</a> is an abstract base class for classes whose memory is managed by an <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a>.  <a href="classion_1_1base_1_1_allocatable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_allocation_manager.html">AllocationManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_allocation_manager.html" title="AllocationManager is a singleton class that is used to manage Allocators used to allocate Ion objects...">AllocationManager</a> is a singleton class that is used to manage Allocators used to allocate Ion objects.  <a href="classion_1_1base_1_1_allocation_manager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_allocation_size_tracker.html">AllocationSizeTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_allocation_size_tracker.html" title="AllocationSizeTracker is an abstract base class for objects that track memory. ">AllocationSizeTracker</a> is an abstract base class for objects that track memory.  <a href="classion_1_1base_1_1_allocation_size_tracker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_allocation_tracker.html">AllocationTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_allocation_tracker.html" title="AllocationTracker is an abstract base class for objects that track memory. ">AllocationTracker</a> is an abstract base class for objects that track memory.  <a href="classion_1_1base_1_1_allocation_tracker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_allocator.html">Allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> is an abstract base class for a memory allocator used for Ion objects derived from <a class="el" href="classion_1_1base_1_1_allocatable.html" title="Allocatable is an abstract base class for classes whose memory is managed by an Allocator. ">Allocatable</a>.  <a href="classion_1_1base_1_1_allocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_array2.html">Array2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple rectangular 2D array class with range-checked indexing, templatized by the element type.  <a href="classion_1_1base_1_1_array2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_call_list.html">CallList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_call_list.html" title="CallList contains a list of function calls to execute. ">CallList</a> contains a list of function calls to execute.  <a href="classion_1_1base_1_1_call_list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_circular_buffer.html">CircularBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple circular buffer class that has fixed capacity and does not grow automatically.  <a href="classion_1_1base_1_1_circular_buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_data_container.html">DataContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classion_1_1base_1_1_data_container.html" title="The DataContainer class encapsulates arbitrary user data passed to Ion. ">DataContainer</a> class encapsulates arbitrary user data passed to Ion.  <a href="classion_1_1base_1_1_data_container.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_date_time.html">DateTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_date_time.html" title="DateTime represents a particular date and time down to the nanosecond level along with timezone infor...">DateTime</a> represents a particular date and time down to the nanosecond level along with timezone information.  <a href="classion_1_1base_1_1_date_time.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_enum_helper.html">EnumHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">}; static const char* kStrings[] = { "Value1", "Value2", "Value3" }; return EnumData&lt;Values&gt;(IndexMap&lt;Values, uint32&gt;(kValues, 3), kStrings); }  <a href="classion_1_1base_1_1_enum_helper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_full_allocation_tracker.html">FullAllocationTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_full_allocation_tracker.html" title="FullAllocationTracker is a derived AllocationTracker class that keeps track of all active allocations...">FullAllocationTracker</a> is a derived <a class="el" href="classion_1_1base_1_1_allocation_tracker.html" title="AllocationTracker is an abstract base class for objects that track memory. ">AllocationTracker</a> class that keeps track of all active allocations and also provides tracing facilities for debugging and error checking of leaked allocations.  <a href="classion_1_1base_1_1_full_allocation_tracker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_function_call_base.html">FunctionCallBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_function_call_base.html" title="FunctionCallBase does nothing but define a virtual operator() to allow containers of arbitrary Functi...">FunctionCallBase</a> does nothing but define a virtual operator() to allow containers of arbitrary FunctionCall&lt;&gt;s.  <a href="classion_1_1base_1_1_function_call_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_function_call.html">FunctionCall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_function_call.html" title="FunctionCall wraps an arbitrary call to a function, including its arguments. ">FunctionCall</a> wraps an arbitrary call to a function, including its arguments.  <a href="classion_1_1base_1_1_function_call.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_function_call_3_01_return_type_07_types_8_8_8_08_4.html">FunctionCall&lt; ReturnType(Types...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for an arbitrary function signature.  <a href="classion_1_1base_1_1_function_call_3_01_return_type_07_types_8_8_8_08_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_index_map.html">IndexMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class can be used to map between two kinds of indices when the following assumptions apply:  <a href="classion_1_1base_1_1_index_map.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_generic_lock_guard_base.html">GenericLockGuardBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains utility classes for automatically locking and unlocking mutexes.  <a href="classion_1_1base_1_1_generic_lock_guard_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_generic_lock_guard.html">GenericLockGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A LockGuard locks a mutex when created, and unlocks it when destroyed.  <a href="classion_1_1base_1_1_generic_lock_guard.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_generic_try_lock_guard.html">GenericTryLockGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A TryLockGuard attempts to lock a mutex when created, and if successful, will unlock it when destroyed.  <a href="classion_1_1base_1_1_generic_try_lock_guard.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_generic_unlock_guard.html">GenericUnlockGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An UnlockGuard is the reverse of a LockGuard; it unlocks a mutex when created and locks it when destroyed.  <a href="classion_1_1base_1_1_generic_unlock_guard.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_manual_lock_guard.html">ManualLockGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_manual_lock_guard.html" title="A ManualLockGuard can be used to protect a variable with a mutex in situations where it is not possib...">ManualLockGuard</a> can be used to protect a variable with a mutex in situations where it is not possible for scoping to be used.  <a href="classion_1_1base_1_1_manual_lock_guard.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_log_checker.html">LogChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classion_1_1base_1_1_log_checker.html" title="The LogChecker class can be used inside unit tests to trap all log output and verify that it matches ...">LogChecker</a> class can be used inside unit tests to trap all log output and verify that it matches what is expected.  <a href="classion_1_1base_1_1_log_checker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_memory_zip_stream.html">MemoryZipStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_memory_zip_stream.html" title="A MemoryZipStream represents ZIP data in memory; the data may represent one or more files or director...">MemoryZipStream</a> represents ZIP data in memory; the data may represent one or more files or directories in ZIP format.  <a href="classion_1_1base_1_1_memory_zip_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_notifier.html">Notifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_notifier.html" title="A Notifier both sends notifications to and receives notifications from other Notifiers. ">Notifier</a> both sends notifications to and receives notifications from other Notifiers.  <a href="classion_1_1base_1_1_notifier.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_null_log_entry_writer.html">NullLogEntryWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_null_log_entry_writer.html" title="A NullLogEntryWriter can be used completely disable all logging programmatically as long as it exists...">NullLogEntryWriter</a> can be used completely disable all logging programmatically as long as it exists.  <a href="classion_1_1base_1_1_null_log_entry_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_once_flag.html">OnceFlag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_once_flag.html" title="OnceFlag ensures that a target function is only evaluated once. ">OnceFlag</a> ensures that a target function is only evaluated once.  <a href="classion_1_1base_1_1_once_flag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_lazy.html">Lazy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily populates a value.  <a href="classion_1_1base_1_1_lazy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_read_write_lock.html">ReadWriteLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classion_1_1base_1_1_read_write_lock.html" title="The ReadWriteLock class defines a non-promotable lock that is very fast when only readers try to obta...">ReadWriteLock</a> class defines a non-promotable lock that is very fast when only readers try to obtain the lock, but slower than a Mutex when there are writers.  <a href="classion_1_1base_1_1_read_write_lock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_read_lock.html">ReadLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_read_lock.html" title="A ReadLock obtains a read lock, but has a similar interface to a Mutex and can be used with a ReadGua...">ReadLock</a> obtains a read lock, but has a similar interface to a Mutex and can be used with a ReadGuard.  <a href="classion_1_1base_1_1_read_lock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_write_lock.html">WriteLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_write_lock.html" title="A WriteLock obtains a write lock, but has a similar interface to a Mutex and can be used with a Write...">WriteLock</a> obtains a write lock, but has a similar interface to a Mutex and can be used with a WriteGuard.  <a href="classion_1_1base_1_1_write_lock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_referent.html">Referent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe abstract base class.  <a href="classion_1_1base_1_1_referent.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_referent_ptr.html">ReferentPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struction_1_1base_1_1_referent_ptr.html" title="A ReferentPtr is a smart shared pointer to an instance of some class derived from Referent...">ReferentPtr</a> is a smart shared pointer to an instance of some class derived from <a class="el" href="classion_1_1base_1_1_referent.html" title="Thread-safe abstract base class. ">Referent</a>.  <a href="struction_1_1base_1_1_referent_ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_scoped_allocation.html">ScopedAllocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class can be used in situations where you want to allocate an object that is not necessarily derived from <a class="el" href="classion_1_1base_1_1_allocatable.html" title="Allocatable is an abstract base class for classes whose memory is managed by an Allocator. ">Allocatable</a>, but you still want to use an <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> for the memory.  <a href="classion_1_1base_1_1_scoped_allocation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_setting_base.html">SettingBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classion_1_1base_1_1_setting.html" title="Forward references. ">Setting</a>, which encapsulates the name of the setting and any functors that should be called via <a class="el" href="classion_1_1base_1_1_setting_base.html#aad7313d03dd8663a7f223749f0c8d17d" title="Notify listeners that this setting has changed. ">NotifyListeners()</a>.  <a href="classion_1_1base_1_1_setting_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_setting_group.html">SettingGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_setting_group.html" title="A SettingGroup is a convenience class to hold Settings that are in the same hierarchical group...">SettingGroup</a> is a convenience class to hold Settings that are in the same hierarchical group.  <a href="classion_1_1base_1_1_setting_group.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_setting.html">Setting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward references.  <a href="classion_1_1base_1_1_setting.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_setting_3_01std_1_1atomic_3_01_t_01_4_01_4.html">Setting&lt; std::atomic&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for std::atomic types.  <a href="classion_1_1base_1_1_setting_3_01std_1_1atomic_3_01_t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_environment_setting.html">EnvironmentSetting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classion_1_1base_1_1_environment_setting.html" title="An EnvironmentSetting is a Setting can take its initial value from the named system environment varia...">EnvironmentSetting</a> is a <a class="el" href="classion_1_1base_1_1_setting.html" title="Forward references. ">Setting</a> can take its initial value from the named system environment variable passed to its constructor.  <a href="classion_1_1base_1_1_environment_setting.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_scoped_setting_value.html">ScopedSettingValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a Setting&lt;T&gt; to a new value.  <a href="classion_1_1base_1_1_scoped_setting_value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_setting_manager.html">SettingManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_setting_manager.html" title="SettingManager tracks all existing SettingBase instances, and allows callers to obtain a map of all s...">SettingManager</a> tracks all existing <a class="el" href="classion_1_1base_1_1_setting_base.html" title="Base class for Setting, which encapsulates the name of the setting and any functors that should be ca...">SettingBase</a> instances, and allows callers to obtain a map of all settings, get a specific setting or listen for when any setting in a group changes.  <a href="classion_1_1base_1_1_setting_manager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_shareable.html">Shareable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_shareable.html" title="Shareable is an abstract base class for any object that can be shared via the SharedPtr class...">Shareable</a> is an abstract base class for any object that can be shared via the <a class="el" href="classion_1_1base_1_1_shared_ptr.html" title="A SharedPtr is a smart shared pointer to an instance of some class that implements reference counting...">SharedPtr</a> class.  <a href="classion_1_1base_1_1_shareable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_shared_ptr.html" title="A SharedPtr is a smart shared pointer to an instance of some class that implements reference counting...">SharedPtr</a> is a smart shared pointer to an instance of some class that implements reference counting.  <a href="classion_1_1base_1_1_shared_ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_spin_mutex.html">SpinMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_spin_mutex.html" title="SpinMutex exposes the same interface as ion::port::Mutex, but implements locking via a simple atomic ...">SpinMutex</a> exposes the same interface as <a class="el" href="classion_1_1port_1_1_mutex.html" title="A Mutex is used to ensure that only one thread or process can access a block of code at one time...">ion::port::Mutex</a>, but implements locking via a simple atomic CAS.  <a href="classion_1_1base_1_1_spin_mutex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_static_deleter_base.html">StaticDeleterBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_static_deleter.html">StaticDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class should not be used directly.  <a href="classion_1_1base_1_1_static_deleter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_static_deleter_3_01_t[]_4.html">StaticDeleter&lt; T[]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for arrays.  <a href="classion_1_1base_1_1_static_deleter_3_01_t[]_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_static_deleter_deleter.html">StaticDeleterDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_static_deleter_deleter.html" title="StaticDeleterDeleter is an internal class that holds and deletes StaticDeleters; it should not be use...">StaticDeleterDeleter</a> is an internal class that holds and deletes StaticDeleters; it should not be used directly.  <a href="classion_1_1base_1_1_static_deleter_deleter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_alloc_deque.html">AllocDeque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used in place of std::deque to allow an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> to be used for memory allocation.  <a href="classion_1_1base_1_1_alloc_deque.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_alloc_map.html">AllocMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used in place of std::map to allow an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> to be used for memory allocation.  <a href="classion_1_1base_1_1_alloc_map.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_alloc_set.html">AllocSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used in place of std::set to allow an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> to be used for memory allocation.  <a href="classion_1_1base_1_1_alloc_set.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_alloc_unordered_map.html">AllocUnorderedMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used in place of std::unordered_map to allow an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> to be used for memory allocation.  <a href="classion_1_1base_1_1_alloc_unordered_map.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_alloc_unordered_set.html">AllocUnorderedSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used in place of std::unordered_set to allow an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> to be used for memory allocation.  <a href="classion_1_1base_1_1_alloc_unordered_set.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_alloc_vector.html">AllocVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used in place of std::vector to allow an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> to be used for memory allocation.  <a href="classion_1_1base_1_1_alloc_vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_inlined_alloc_vector.html">InlinedAllocVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">InlinedAllocVectoris a similar to <a class="el" href="classion_1_1base_1_1_alloc_vector.html" title="This class can be used in place of std::vector to allow an Ion Allocator to be used for memory alloca...">AllocVector</a>, but uses inlined storage for its first N elements, then uses an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> if that size is exceeded.  <a href="classion_1_1base_1_1_inlined_alloc_vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_stl_allocator.html">StlAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_stl_allocator.html" title="StlAllocator is derived std::allocator class that allows an Ion Allocator to be used for STL containe...">StlAllocator</a> is derived std::allocator class that allows an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> to be used for STL containers.  <a href="classion_1_1base_1_1_stl_allocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_stl_inlined_allocator.html">StlInlinedAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_stl_inlined_allocator.html" title="StlInlinedAllocator is a derived StlAllocator class that uses inlined storage for its first N element...">StlInlinedAllocator</a> is a derived <a class="el" href="classion_1_1base_1_1_stl_allocator.html" title="StlAllocator is derived std::allocator class that allows an Ion Allocator to be used for STL containe...">StlAllocator</a> class that uses inlined storage for its first N elements, then uses an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> if that size is exceeded.  <a href="classion_1_1base_1_1_stl_inlined_allocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_thread_local_object.html">ThreadLocalObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This templated class makes it easy to create an instance of an object in thread-local storage.  <a href="classion_1_1base_1_1_thread_local_object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_thread_spawner.html">ThreadSpawner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_thread_spawner.html" title="A ThreadSpawner instance launches a new thread in its constructor and waits for the thread to finish ...">ThreadSpawner</a> instance launches a new thread in its constructor and waits for the thread to finish in its destructor.  <a href="classion_1_1base_1_1_thread_spawner.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_bool_type.html">BoolType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struction_1_1base_1_1_bool_type.html" title="BoolType is a struct whose value member is either true or false. ">BoolType</a> is a struct whose value member is either true or false.  <a href="struction_1_1base_1_1_bool_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_is_same_type.html">IsSameType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struction_1_1base_1_1_is_same_type.html" title="IsSameType is similar to std::is_same. ">IsSameType</a> is similar to std::is_same.  <a href="struction_1_1base_1_1_is_same_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_is_same_type_3_01_t_00_01_t_01_4.html">IsSameType&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_is_base_of.html">IsBaseOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struction_1_1base_1_1_is_base_of.html" title="IsBaseOf is similar to std::is_base_of. ">IsBaseOf</a> is similar to std::is_base_of.  <a href="struction_1_1base_1_1_is_base_of.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_is_convertible.html">IsConvertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struction_1_1base_1_1_is_convertible.html" title="IsConvertible is similar to std::is_convertible, except that it only looks at direct inheritance rela...">IsConvertible</a> is similar to std::is_convertible, except that it only looks at direct inheritance relationships (e.g.  <a href="struction_1_1base_1_1_is_convertible.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_conditional_type.html">ConditionalType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struction_1_1base_1_1_conditional_type.html" title="ConditionalType is similar to std::conditional. ">ConditionalType</a> is similar to std::conditional.  <a href="struction_1_1base_1_1_conditional_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_conditional_type_3_01false_00_01_a_00_01_b_01_4.html">ConditionalType&lt; false, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_has_trivial_destructor.html">HasTrivialDestructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struction_1_1base_1_1_has_trivial_destructor.html" title="HasTrivialDestructor is similar to std::has_trivial_destructor or std::is_trivially_destructible. ">HasTrivialDestructor</a> is similar to std::has_trivial_destructor or std::is_trivially_destructible.  <a href="struction_1_1base_1_1_has_trivial_destructor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_utf8_iterator.html">Utf8Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classion_1_1base_1_1_utf8_iterator.html" title="The Utf8Iterator class iterates over characters in strings encoded with UTF-8, extracting the Unicode...">Utf8Iterator</a> class iterates over characters in strings encoded with UTF-8, extracting the Unicode index for each character.  <a href="classion_1_1base_1_1_utf8_iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_variant.html">Variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classion_1_1base_1_1_variant.html" title="The Variant class is similar to boost::variant. ">Variant</a> class is similar to boost::variant.  <a href="classion_1_1base_1_1_variant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struction_1_1base_1_1_variant_type_resolver.html">VariantTypeResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struction_1_1base_1_1_variant_type_resolver.html" title="The VariantTypeResolver struct allows users of the Variant class to determine which type defined by a...">VariantTypeResolver</a> struct allows users of the <a class="el" href="classion_1_1base_1_1_variant.html" title="The Variant class is similar to boost::variant. ">Variant</a> class to determine which type defined by a particular <a class="el" href="classion_1_1base_1_1_variant.html" title="The Variant class is similar to boost::variant. ">Variant</a> can be used to store a value of a particular type.  <a href="struction_1_1base_1_1_variant_type_resolver.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_vector_data_container.html">VectorDataContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_vector_data_container.html" title="VectorDataContainer is a special kind of DataContainer that is backed by an AllocVector. ">VectorDataContainer</a> is a special kind of <a class="el" href="classion_1_1base_1_1_data_container.html" title="The DataContainer class encapsulates arbitrary user data passed to Ion. ">DataContainer</a> that is backed by an <a class="el" href="classion_1_1base_1_1_alloc_vector.html" title="This class can be used in place of std::vector to allow an Ion Allocator to be used for memory alloca...">AllocVector</a>.  <a href="classion_1_1base_1_1_vector_data_container.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_weak_referent.html">WeakReferent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class that inherits from <a class="el" href="classion_1_1base_1_1_referent.html" title="Thread-safe abstract base class. ">Referent</a>, and adds the ability for instances to be referenced by a <a class="el" href="classion_1_1base_1_1_weak_referent_ptr.html" title="A WeakReferentPtr is a weak reference to an instance of some class derived from Referent. ">WeakReferentPtr</a>.  <a href="classion_1_1base_1_1_weak_referent.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_weak_referent_ptr.html">WeakReferentPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classion_1_1base_1_1_weak_referent_ptr.html" title="A WeakReferentPtr is a weak reference to an instance of some class derived from Referent. ">WeakReferentPtr</a> is a weak reference to an instance of some class derived from <a class="el" href="classion_1_1base_1_1_referent.html" title="Thread-safe abstract base class. ">Referent</a>.  <a href="classion_1_1base_1_1_weak_referent_ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_worker_pool.html">WorkerPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages one or more threads that run in a loop, performing some work with each iteration (if any work is available).  <a href="classion_1_1base_1_1_worker_pool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classion_1_1base_1_1_zip_asset_manager.html">ZipAssetManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_zip_asset_manager.html" title="ZipAssetManager manages all zipfile assets in Ion. ">ZipAssetManager</a> manages all zipfile assets in Ion.  <a href="classion_1_1base_1_1_zip_asset_manager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab2c3e3e952284ecabd82c1e941c93f28"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_allocation_size_tracker.html">AllocationSizeTracker</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ab2c3e3e952284ecabd82c1e941c93f28">AllocationSizeTrackerPtr</a></td></tr>
<tr class="memdesc:ab2c3e3e952284ecabd82c1e941c93f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef for shared pointer to a <a class="el" href="classion_1_1base_1_1_allocation_size_tracker.html" title="AllocationSizeTracker is an abstract base class for objects that track memory. ">AllocationSizeTracker</a>.  <a href="#ab2c3e3e952284ecabd82c1e941c93f28">More...</a><br/></td></tr>
<tr class="separator:ab2c3e3e952284ecabd82c1e941c93f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44de58eef8b3c63067c79b5c73752a8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_allocation_tracker.html">AllocationTracker</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#af44de58eef8b3c63067c79b5c73752a8">AllocationTrackerPtr</a></td></tr>
<tr class="memdesc:af44de58eef8b3c63067c79b5c73752a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef for shared pointer to an <a class="el" href="classion_1_1base_1_1_allocation_tracker.html" title="AllocationTracker is an abstract base class for objects that track memory. ">AllocationTracker</a>.  <a href="#af44de58eef8b3c63067c79b5c73752a8">More...</a><br/></td></tr>
<tr class="separator:af44de58eef8b3c63067c79b5c73752a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c6663b5bdd5e5839eba0729b613c28"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a>&lt; <a class="el" href="classion_1_1base_1_1_allocator.html">Allocator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a43c6663b5bdd5e5839eba0729b613c28">AllocatorPtr</a></td></tr>
<tr class="separator:a43c6663b5bdd5e5839eba0729b613c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe5a4355abc33ba2c1d569043eaf8ca"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struction_1_1base_1_1_referent_ptr.html">ReferentPtr</a>&lt; <a class="el" href="classion_1_1base_1_1_call_list.html">CallList</a> &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a7fe5a4355abc33ba2c1d569043eaf8ca">CallListPtr</a></td></tr>
<tr class="separator:a7fe5a4355abc33ba2c1d569043eaf8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aea056fa3b5c46e3182f5427fb5f010"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struction_1_1base_1_1_referent_ptr.html">base::ReferentPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_data_container.html">DataContainer</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a9aea056fa3b5c46e3182f5427fb5f010">DataContainerPtr</a></td></tr>
<tr class="separator:a9aea056fa3b5c46e3182f5427fb5f010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99486dfa472f32bce7889ff0e3c54a9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_weak_referent_ptr.html">base::WeakReferentPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_data_container.html">DataContainer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ad99486dfa472f32bce7889ff0e3c54a9">DataContainerWeakPtr</a></td></tr>
<tr class="separator:ad99486dfa472f32bce7889ff0e3c54a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c4bcb7abfff8283044dc97409ffabc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_full_allocation_tracker.html">FullAllocationTracker</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a56c4bcb7abfff8283044dc97409ffabc">FullAllocationTrackerPtr</a></td></tr>
<tr class="memdesc:a56c4bcb7abfff8283044dc97409ffabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef for shared pointer to a <a class="el" href="classion_1_1base_1_1_full_allocation_tracker.html" title="FullAllocationTracker is a derived AllocationTracker class that keeps track of all active allocations...">FullAllocationTracker</a>.  <a href="#a56c4bcb7abfff8283044dc97409ffabc">More...</a><br/></td></tr>
<tr class="separator:a56c4bcb7abfff8283044dc97409ffabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d42b89a77ac34d6dff5e676032778b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_generic_lock_guard.html">GenericLockGuard</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1port_1_1_mutex.html">port::Mutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aa3d42b89a77ac34d6dff5e676032778b">LockGuard</a></td></tr>
<tr class="memdesc:aa3d42b89a77ac34d6dff5e676032778b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient typedefs for <a class="el" href="classion_1_1port_1_1_mutex.html" title="A Mutex is used to ensure that only one thread or process can access a block of code at one time...">ion::port::Mutex</a>.  <a href="#aa3d42b89a77ac34d6dff5e676032778b">More...</a><br/></td></tr>
<tr class="separator:aa3d42b89a77ac34d6dff5e676032778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6d478dc70549e7bad6d824b5a827fc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_generic_unlock_guard.html">GenericUnlockGuard</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1port_1_1_mutex.html">port::Mutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aec6d478dc70549e7bad6d824b5a827fc">UnlockGuard</a></td></tr>
<tr class="separator:aec6d478dc70549e7bad6d824b5a827fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32c09756509bc7d623f6d5e5730607f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_generic_try_lock_guard.html">GenericTryLockGuard</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1port_1_1_mutex.html">port::Mutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aa32c09756509bc7d623f6d5e5730607f">TryLockGuard</a></td></tr>
<tr class="separator:aa32c09756509bc7d623f6d5e5730607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3f0ff730a8e9b63c30211afc15894a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_generic_lock_guard.html">GenericLockGuard</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_spin_mutex.html">SpinMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a9b3f0ff730a8e9b63c30211afc15894a">SpinLockGuard</a></td></tr>
<tr class="memdesc:a9b3f0ff730a8e9b63c30211afc15894a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient typedefs for <a class="el" href="classion_1_1base_1_1_spin_mutex.html" title="SpinMutex exposes the same interface as ion::port::Mutex, but implements locking via a simple atomic ...">SpinMutex</a>.  <a href="#a9b3f0ff730a8e9b63c30211afc15894a">More...</a><br/></td></tr>
<tr class="separator:a9b3f0ff730a8e9b63c30211afc15894a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6705573b0cb8241baede450b5e812f97"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_generic_unlock_guard.html">GenericUnlockGuard</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_spin_mutex.html">SpinMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a6705573b0cb8241baede450b5e812f97">SpinUnlockGuard</a></td></tr>
<tr class="separator:a6705573b0cb8241baede450b5e812f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b0c7af7ff18e4a714b80651b6e7855"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_generic_try_lock_guard.html">GenericTryLockGuard</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_spin_mutex.html">SpinMutex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ae1b0c7af7ff18e4a714b80651b6e7855">SpinTryLockGuard</a></td></tr>
<tr class="separator:ae1b0c7af7ff18e4a714b80651b6e7855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab470a11cceef7441df42bf6f489a69e5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_generic_lock_guard.html">GenericLockGuard</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_read_lock.html">ReadLock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ab470a11cceef7441df42bf6f489a69e5">ReadGuard</a></td></tr>
<tr class="memdesc:ab470a11cceef7441df42bf6f489a69e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient typedefs for <a class="el" href="classion_1_1base_1_1_read_write_lock.html" title="The ReadWriteLock class defines a non-promotable lock that is very fast when only readers try to obta...">ReadWriteLock</a>.  <a href="#ab470a11cceef7441df42bf6f489a69e5">More...</a><br/></td></tr>
<tr class="separator:ab470a11cceef7441df42bf6f489a69e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa710835f4c8519208e8640e83e9a95db"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classion_1_1base_1_1_generic_lock_guard.html">GenericLockGuard</a><br class="typebreak"/>
&lt; <a class="el" href="classion_1_1base_1_1_write_lock.html">WriteLock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aa710835f4c8519208e8640e83e9a95db">WriteGuard</a></td></tr>
<tr class="separator:aa710835f4c8519208e8640e83e9a95db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5fca7f9340dcefae18f258053de7757c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a5fca7f9340dcefae18f258053de7757c">AllocationLifetime</a> { <br/>
&#160;&#160;<a class="el" href="namespaceion_1_1base.html#a5fca7f9340dcefae18f258053de7757ca0e572cccc7b2f48ced01134b3acc3396">kShortTerm</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceion_1_1base.html#a5fca7f9340dcefae18f258053de7757caf03f24745ec5729b9c4ba500f7ff654d">kMediumTerm</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceion_1_1base.html#a5fca7f9340dcefae18f258053de7757cae13e720cb817ed225d324290a0acd4f0">kLongTerm</a>
<br/>
 }</td></tr>
<tr class="memdesc:a5fca7f9340dcefae18f258053de7757c"><td class="mdescLeft">&#160;</td><td class="mdescRight">All memory allocated within Ion uses an Allocator chosen based on the predicted lifetime of the target object.  <a href="namespaceion_1_1base.html#a5fca7f9340dcefae18f258053de7757c">More...</a><br/></td></tr>
<tr class="separator:a5fca7f9340dcefae18f258053de7757c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a63e51b10be4e4145652f551a0f77a01b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a63e51b10be4e4145652f551a0f77a01b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classion_1_1base_1_1_date_time.html">DateTime</a> &amp;dtime)</td></tr>
<tr class="separator:a63e51b10be4e4145652f551a0f77a01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68791b943a463bbfce5b44945311842"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ab68791b943a463bbfce5b44945311842">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classion_1_1base_1_1_date_time.html">DateTime</a> &amp;dtime)</td></tr>
<tr class="separator:ab68791b943a463bbfce5b44945311842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62eaa5f45ca6b9f446ca128679860ead"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62eaa5f45ca6b9f446ca128679860ead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a62eaa5f45ca6b9f446ca128679860ead">IsInvalidReference</a> (const <a class="el" href="class_t.html">T</a> &amp;<a class="el" href="printer_8cc.html#a5c33da5929c9f2f9ef8d006d2350e6ec">value</a>)</td></tr>
<tr class="memdesc:a62eaa5f45ca6b9f446ca128679860ead"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceion_1_1base.html#a62eaa5f45ca6b9f446ca128679860ead" title="IsInvalidReference() returns true if a passed const reference of type T has an address of InvalidRefe...">IsInvalidReference()</a> returns true if a passed const reference of type <a class="el" href="class_t.html">T</a> has an address of InvalidReference&lt;T&gt;().  <a href="#a62eaa5f45ca6b9f446ca128679860ead">More...</a><br/></td></tr>
<tr class="separator:a62eaa5f45ca6b9f446ca128679860ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d3865496a66b90d413b60dadc40407"><td class="memTemplParams" colspan="2">template&lt;typename EnumType &gt; </td></tr>
<tr class="memitem:a12d3865496a66b90d413b60dadc40407"><td class="memTemplItemLeft" align="right" valign="top">EnumType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a12d3865496a66b90d413b60dadc40407">InvalidEnumValue</a> ()</td></tr>
<tr class="memdesc:a12d3865496a66b90d413b60dadc40407"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceion_1_1base.html#a12d3865496a66b90d413b60dadc40407" title="InvalidEnumValue() returns an invalid enum value, assuming that -1 is not a valid value...">InvalidEnumValue()</a> returns an invalid enum value, assuming that -1 is not a valid value.  <a href="#a12d3865496a66b90d413b60dadc40407">More...</a><br/></td></tr>
<tr class="separator:a12d3865496a66b90d413b60dadc40407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955bfd777c3064212e886ec9bde1a670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a955bfd777c3064212e886ec9bde1a670">SetLogEntryWriter</a> (<a class="el" href="classion_1_1port_1_1_log_entry_writer.html">port::LogEntryWriter</a> *w)</td></tr>
<tr class="memdesc:a955bfd777c3064212e886ec9bde1a670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public functions.  <a href="#a955bfd777c3064212e886ec9bde1a670">More...</a><br/></td></tr>
<tr class="separator:a955bfd777c3064212e886ec9bde1a670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcfa31bd13cbf539845f73f0e49ceb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classion_1_1port_1_1_log_entry_writer.html">port::LogEntryWriter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a9bcfa31bd13cbf539845f73f0e49ceb4">GetLogEntryWriter</a> ()</td></tr>
<tr class="memdesc:a9bcfa31bd13cbf539845f73f0e49ceb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log-writer that messages are currently logged to.  <a href="#a9bcfa31bd13cbf539845f73f0e49ceb4">More...</a><br/></td></tr>
<tr class="separator:a9bcfa31bd13cbf539845f73f0e49ceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c656c70a6ae096b214f19095c9b00b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classion_1_1port_1_1_log_entry_writer.html">port::LogEntryWriter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ad4c656c70a6ae096b214f19095c9b00b">GetDefaultLogEntryWriter</a> ()</td></tr>
<tr class="memdesc:ad4c656c70a6ae096b214f19095c9b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log-writer that messages will be logged to if if another is not explicitly specified via <a class="el" href="namespaceion_1_1base.html#a955bfd777c3064212e886ec9bde1a670" title="Public functions. ">SetLogEntryWriter()</a>.  <a href="#ad4c656c70a6ae096b214f19095c9b00b">More...</a><br/></td></tr>
<tr class="separator:ad4c656c70a6ae096b214f19095c9b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d63ed65684a747bf5d05515aec36a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a7d63ed65684a747bf5d05515aec36a95">SetBreakHandler</a> (const std::function&lt; void()&gt; &amp;break_handler)</td></tr>
<tr class="memdesc:a7d63ed65684a747bf5d05515aec36a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a custom break handler that gets invoked by Logger::CheckMessage.  <a href="#a7d63ed65684a747bf5d05515aec36a95">More...</a><br/></td></tr>
<tr class="separator:a7d63ed65684a747bf5d05515aec36a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50433725be84a02efd91a7d9a583314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aa50433725be84a02efd91a7d9a583314">RestoreDefaultBreakHandler</a> ()</td></tr>
<tr class="memdesc:aa50433725be84a02efd91a7d9a583314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the default break handler (port::BreakAndAbort).  <a href="#aa50433725be84a02efd91a7d9a583314">More...</a><br/></td></tr>
<tr class="separator:aa50433725be84a02efd91a7d9a583314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5ce99df0e50584507f4c04cf4ddb42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc5ce99df0e50584507f4c04cf4ddb42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#afc5ce99df0e50584507f4c04cf4ddb42">StringToValue</a> (std::istringstream &amp;in, <a class="el" href="class_t.html">T</a> *val)</td></tr>
<tr class="memdesc:afc5ce99df0e50584507f4c04cf4ddb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines two public functions: <a class="el" href="namespaceion_1_1base.html#afc5ce99df0e50584507f4c04cf4ddb42" title="This file defines two public functions: StringToValue() and ValueToString(). ">StringToValue()</a> and <a class="el" href="namespaceion_1_1base.html#a38945775ca691f4c7e2d186567037995" title="ValueToString. ">ValueToString()</a>.  <a href="#afc5ce99df0e50584507f4c04cf4ddb42">More...</a><br/></td></tr>
<tr class="separator:afc5ce99df0e50584507f4c04cf4ddb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b7613ccc25ea0e8426a295adb76e51"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a11b7613ccc25ea0e8426a295adb76e51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a11b7613ccc25ea0e8426a295adb76e51">StringToValue</a> (std::istringstream &amp;in, <a class="el" href="classbool.html">bool</a> *val)</td></tr>
<tr class="memdesc:a11b7613ccc25ea0e8426a295adb76e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for bools.  <a href="#a11b7613ccc25ea0e8426a295adb76e51">More...</a><br/></td></tr>
<tr class="separator:a11b7613ccc25ea0e8426a295adb76e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb3b55167510d458eecc1143be224c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V &gt; </td></tr>
<tr class="memitem:a7fb3b55167510d458eecc1143be224c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a7fb3b55167510d458eecc1143be224c7">StringToValue</a> (std::istringstream &amp;in, std::basic_string&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a> &gt; *val)</td></tr>
<tr class="memdesc:a7fb3b55167510d458eecc1143be224c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for reading double quoted strings.  <a href="#a7fb3b55167510d458eecc1143be224c7">More...</a><br/></td></tr>
<tr class="separator:a7fb3b55167510d458eecc1143be224c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171c7c50b1c03368cb5bcbceedc9e3ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a171c7c50b1c03368cb5bcbceedc9e3ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a171c7c50b1c03368cb5bcbceedc9e3ce">StringToValue</a> (std::istringstream &amp;in, std::pair&lt; const <a class="el" href="class_t.html">T</a>, U &gt; *val)</td></tr>
<tr class="memdesc:a171c7c50b1c03368cb5bcbceedc9e3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::pair types.  <a href="#a171c7c50b1c03368cb5bcbceedc9e3ce">More...</a><br/></td></tr>
<tr class="separator:a171c7c50b1c03368cb5bcbceedc9e3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfabaf1f67063167064bb2663cd3fdd"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:a3bfabaf1f67063167064bb2663cd3fdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a3bfabaf1f67063167064bb2663cd3fdd">StringToStlContainer</a> (std::istringstream &amp;in, ContainerType *val)</td></tr>
<tr class="memdesc:a3bfabaf1f67063167064bb2663cd3fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a STL container from a stream.  <a href="#a3bfabaf1f67063167064bb2663cd3fdd">More...</a><br/></td></tr>
<tr class="separator:a3bfabaf1f67063167064bb2663cd3fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381cf52f71d6735b1be93fe17a8771e7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename W , typename X , bool B, template&lt; class, class, class, class, class, bool &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:a381cf52f71d6735b1be93fe17a8771e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a381cf52f71d6735b1be93fe17a8771e7">StringToValue</a> (std::istringstream &amp;in, ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, X, B &gt; *val)</td></tr>
<tr class="memdesc:a381cf52f71d6735b1be93fe17a8771e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::unordered_map with a bool at the end.  <a href="#a381cf52f71d6735b1be93fe17a8771e7">More...</a><br/></td></tr>
<tr class="separator:a381cf52f71d6735b1be93fe17a8771e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b88e4b16ce819d8ee00022ec1f8616"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename W , typename X , template&lt; class, class, class, class, class &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:ae5b88e4b16ce819d8ee00022ec1f8616"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ae5b88e4b16ce819d8ee00022ec1f8616">StringToValue</a> (std::istringstream &amp;in, ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, X &gt; *val)</td></tr>
<tr class="memdesc:ae5b88e4b16ce819d8ee00022ec1f8616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::unordered_map without a bool at the end.  <a href="#ae5b88e4b16ce819d8ee00022ec1f8616">More...</a><br/></td></tr>
<tr class="separator:ae5b88e4b16ce819d8ee00022ec1f8616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128a6e0d55f027c7b629c628d21ad601"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename W , bool B, template&lt; class, class, class, class, bool &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:a128a6e0d55f027c7b629c628d21ad601"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a128a6e0d55f027c7b629c628d21ad601">StringToValue</a> (std::istringstream &amp;in, ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, B &gt; *val)</td></tr>
<tr class="memdesc:a128a6e0d55f027c7b629c628d21ad601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::unordered_set with a bool at the end.  <a href="#a128a6e0d55f027c7b629c628d21ad601">More...</a><br/></td></tr>
<tr class="separator:a128a6e0d55f027c7b629c628d21ad601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607b871c08ef0c991b4a9519607d2b12"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename W , template&lt; class, class, class, class &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:a607b871c08ef0c991b4a9519607d2b12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a607b871c08ef0c991b4a9519607d2b12">StringToValue</a> (std::istringstream &amp;in, ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W &gt; *val)</td></tr>
<tr class="memdesc:a607b871c08ef0c991b4a9519607d2b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::map and std::unordered_set without a bool at the end.  <a href="#a607b871c08ef0c991b4a9519607d2b12">More...</a><br/></td></tr>
<tr class="separator:a607b871c08ef0c991b4a9519607d2b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90745d3418ce34d967013d54a8a318fe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , template&lt; class, class, class &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:a90745d3418ce34d967013d54a8a318fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a90745d3418ce34d967013d54a8a318fe">StringToValue</a> (std::istringstream &amp;in, ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a> &gt; *val)</td></tr>
<tr class="memdesc:a90745d3418ce34d967013d54a8a318fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::set.  <a href="#a90745d3418ce34d967013d54a8a318fe">More...</a><br/></td></tr>
<tr class="separator:a90745d3418ce34d967013d54a8a318fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733453960fc67677d3e232179feb197b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , template&lt; class, class &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:a733453960fc67677d3e232179feb197b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a733453960fc67677d3e232179feb197b">StringToValue</a> (std::istringstream &amp;in, ContainerType&lt; <a class="el" href="class_t.html">T</a>, U &gt; *val)</td></tr>
<tr class="memdesc:a733453960fc67677d3e232179feb197b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for STL containers like deque, list, vector.  <a href="#a733453960fc67677d3e232179feb197b">More...</a><br/></td></tr>
<tr class="separator:a733453960fc67677d3e232179feb197b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f54ab455c29a0e0473eae13c5da32f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f54ab455c29a0e0473eae13c5da32f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a2f54ab455c29a0e0473eae13c5da32f0">StringToValue</a> (const std::string &amp;s, <a class="el" href="class_t.html">T</a> *val)</td></tr>
<tr class="memdesc:a2f54ab455c29a0e0473eae13c5da32f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that converts a std::string to a <a class="el" href="class_t.html">T</a>, constructing the istringstream automatically.  <a href="#a2f54ab455c29a0e0473eae13c5da32f0">More...</a><br/></td></tr>
<tr class="separator:a2f54ab455c29a0e0473eae13c5da32f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38945775ca691f4c7e2d186567037995"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38945775ca691f4c7e2d186567037995"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a38945775ca691f4c7e2d186567037995">ValueToString</a> (const <a class="el" href="class_t.html">T</a> &amp;val)</td></tr>
<tr class="memdesc:a38945775ca691f4c7e2d186567037995"><td class="mdescLeft">&#160;</td><td class="mdescRight">ValueToString.  <a href="#a38945775ca691f4c7e2d186567037995">More...</a><br/></td></tr>
<tr class="separator:a38945775ca691f4c7e2d186567037995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c71e09500e8fae9d728080e709667c4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8c71e09500e8fae9d728080e709667c4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a8c71e09500e8fae9d728080e709667c4">ValueToString</a> (const <a class="el" href="classbool.html">bool</a> &amp;val)</td></tr>
<tr class="memdesc:a8c71e09500e8fae9d728080e709667c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for bools.  <a href="#a8c71e09500e8fae9d728080e709667c4">More...</a><br/></td></tr>
<tr class="separator:a8c71e09500e8fae9d728080e709667c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa602b7adf7c6c9393099f30e18c0cffb"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa602b7adf7c6c9393099f30e18c0cffb"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aa602b7adf7c6c9393099f30e18c0cffb">ValueToString</a> (const float &amp;val)</td></tr>
<tr class="memdesc:aa602b7adf7c6c9393099f30e18c0cffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for printing significant digits of floating point numbers.  <a href="#aa602b7adf7c6c9393099f30e18c0cffb">More...</a><br/></td></tr>
<tr class="separator:aa602b7adf7c6c9393099f30e18c0cffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42d941eee7dd605beb09599df28881b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad42d941eee7dd605beb09599df28881b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ad42d941eee7dd605beb09599df28881b">ValueToString</a> (const double &amp;val)</td></tr>
<tr class="separator:ad42d941eee7dd605beb09599df28881b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8153ca5be2fee5c486e8d11194be5d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V &gt; </td></tr>
<tr class="memitem:abe8153ca5be2fee5c486e8d11194be5d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#abe8153ca5be2fee5c486e8d11194be5d">ValueToString</a> (const std::basic_string&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:abe8153ca5be2fee5c486e8d11194be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for writing double quoted strings.  <a href="#abe8153ca5be2fee5c486e8d11194be5d">More...</a><br/></td></tr>
<tr class="separator:abe8153ca5be2fee5c486e8d11194be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058c5f0c7414b7275949b4fcd0e51d3f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a058c5f0c7414b7275949b4fcd0e51d3f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a058c5f0c7414b7275949b4fcd0e51d3f">ValueToString</a> (const char *const &amp;val)</td></tr>
<tr class="memdesc:a058c5f0c7414b7275949b4fcd0e51d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for writing double quoted C-strings.  <a href="#a058c5f0c7414b7275949b4fcd0e51d3f">More...</a><br/></td></tr>
<tr class="separator:a058c5f0c7414b7275949b4fcd0e51d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7938ddc96c30ef3bde0a83637ebf37d8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7938ddc96c30ef3bde0a83637ebf37d8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a7938ddc96c30ef3bde0a83637ebf37d8">ValueToString</a> (const std::pair&lt; const <a class="el" href="class_t.html">T</a>, U &gt; &amp;val)</td></tr>
<tr class="memdesc:a7938ddc96c30ef3bde0a83637ebf37d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::pair types.  <a href="#a7938ddc96c30ef3bde0a83637ebf37d8">More...</a><br/></td></tr>
<tr class="separator:a7938ddc96c30ef3bde0a83637ebf37d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f992726c8861db59358d3793568a95e"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:a2f992726c8861db59358d3793568a95e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a2f992726c8861db59358d3793568a95e">StlContainerToString</a> (const ContainerType &amp;c)</td></tr>
<tr class="memdesc:a2f992726c8861db59358d3793568a95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an STL container to a string.  <a href="#a2f992726c8861db59358d3793568a95e">More...</a><br/></td></tr>
<tr class="separator:a2f992726c8861db59358d3793568a95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895e58f7de30d18c41a5cef341068a03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename W , typename X , bool B, template&lt; class, class, class, class, class, bool &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:a895e58f7de30d18c41a5cef341068a03"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a895e58f7de30d18c41a5cef341068a03">ValueToString</a> (const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, X, B &gt; &amp;val)</td></tr>
<tr class="memdesc:a895e58f7de30d18c41a5cef341068a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::unordered_map with a bool at the end.  <a href="#a895e58f7de30d18c41a5cef341068a03">More...</a><br/></td></tr>
<tr class="separator:a895e58f7de30d18c41a5cef341068a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39ef8a06cde9950f3efe7a93567bf14"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename W , typename X , template&lt; class, class, class, class, class &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:ab39ef8a06cde9950f3efe7a93567bf14"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ab39ef8a06cde9950f3efe7a93567bf14">ValueToString</a> (const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, X &gt; &amp;val)</td></tr>
<tr class="memdesc:ab39ef8a06cde9950f3efe7a93567bf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::unordered_map without a bool at the end.  <a href="#ab39ef8a06cde9950f3efe7a93567bf14">More...</a><br/></td></tr>
<tr class="separator:ab39ef8a06cde9950f3efe7a93567bf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d36d49a044fb1b07df27099eea420"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename W , bool B, template&lt; class, class, class, class, bool &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:abb5d36d49a044fb1b07df27099eea420"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#abb5d36d49a044fb1b07df27099eea420">ValueToString</a> (const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, B &gt; &amp;val)</td></tr>
<tr class="memdesc:abb5d36d49a044fb1b07df27099eea420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::unordered_set with a bool at the end.  <a href="#abb5d36d49a044fb1b07df27099eea420">More...</a><br/></td></tr>
<tr class="separator:abb5d36d49a044fb1b07df27099eea420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3aa6da95f908ce77d015e6128d6c6f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename W , template&lt; class, class, class, class &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:a2e3aa6da95f908ce77d015e6128d6c6f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a2e3aa6da95f908ce77d015e6128d6c6f">ValueToString</a> (const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W &gt; &amp;val)</td></tr>
<tr class="memdesc:a2e3aa6da95f908ce77d015e6128d6c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::map and std::unordered_set without a bool at the end.  <a href="#a2e3aa6da95f908ce77d015e6128d6c6f">More...</a><br/></td></tr>
<tr class="separator:a2e3aa6da95f908ce77d015e6128d6c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bfe3c19d76734f325dd4c0eae22f09"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , template&lt; class, class, class &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:ae7bfe3c19d76734f325dd4c0eae22f09"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ae7bfe3c19d76734f325dd4c0eae22f09">ValueToString</a> (const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:ae7bfe3c19d76734f325dd4c0eae22f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for std::set.  <a href="#ae7bfe3c19d76734f325dd4c0eae22f09">More...</a><br/></td></tr>
<tr class="separator:ae7bfe3c19d76734f325dd4c0eae22f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49af2bfa1b175239a4dfc1d65d1f0f55"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , template&lt; class, class &gt; class ContainerType&gt; </td></tr>
<tr class="memitem:a49af2bfa1b175239a4dfc1d65d1f0f55"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a49af2bfa1b175239a4dfc1d65d1f0f55">ValueToString</a> (const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U &gt; &amp;val)</td></tr>
<tr class="memdesc:a49af2bfa1b175239a4dfc1d65d1f0f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for non-associative STL containers (deque, list, vector).  <a href="#a49af2bfa1b175239a4dfc1d65d1f0f55">More...</a><br/></td></tr>
<tr class="separator:a49af2bfa1b175239a4dfc1d65d1f0f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93f0b9bc825991bd2aa5d33245e0543"><td class="memTemplParams" colspan="2">template&lt;typename SettingType &gt; </td></tr>
<tr class="memitem:ad93f0b9bc825991bd2aa5d33245e0543"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ad93f0b9bc825991bd2aa5d33245e0543">SetTypeDescriptorForType</a> (SettingType *setting)</td></tr>
<tr class="memdesc:ad93f0b9bc825991bd2aa5d33245e0543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type descriptor string of a setting based on its type.  <a href="#ad93f0b9bc825991bd2aa5d33245e0543">More...</a><br/></td></tr>
<tr class="separator:ad93f0b9bc825991bd2aa5d33245e0543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814b66b3576191b9dd9863ea5e65ec66"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a814b66b3576191b9dd9863ea5e65ec66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a814b66b3576191b9dd9863ea5e65ec66">SetTypeDescriptorForType</a> (<a class="el" href="classion_1_1base_1_1_setting.html">Setting</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; *setting)</td></tr>
<tr class="memdesc:a814b66b3576191b9dd9863ea5e65ec66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean settings set the descriptor to "bool".  <a href="#a814b66b3576191b9dd9863ea5e65ec66">More...</a><br/></td></tr>
<tr class="separator:a814b66b3576191b9dd9863ea5e65ec66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca144f74762a940cea0c89061339552a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aca144f74762a940cea0c89061339552a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aca144f74762a940cea0c89061339552a">SetTypeDescriptorForType</a> (<a class="el" href="classion_1_1base_1_1_setting.html">Setting</a>&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; *setting)</td></tr>
<tr class="separator:aca144f74762a940cea0c89061339552a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cab5e1cde59e83842461ad4a7835342"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a9cab5e1cde59e83842461ad4a7835342"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a>&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a9cab5e1cde59e83842461ad4a7835342">DynamicPtrCast</a> (const <a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a>&lt; From &gt; &amp;orig)</td></tr>
<tr class="memdesc:a9cab5e1cde59e83842461ad4a7835342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows casting SharedPtrs down a type hierarchy.  <a href="#a9cab5e1cde59e83842461ad4a7835342">More...</a><br/></td></tr>
<tr class="separator:a9cab5e1cde59e83842461ad4a7835342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea07ae7e8734c2303603023e8b05639f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aea07ae7e8734c2303603023e8b05639f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aea07ae7e8734c2303603023e8b05639f">operator==</a> (const <a class="el" href="classion_1_1base_1_1_stl_allocator.html">StlAllocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="classion_1_1base_1_1_stl_allocator.html">StlAllocator</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aea07ae7e8734c2303603023e8b05639f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each <a class="el" href="classion_1_1base_1_1_stl_allocator.html" title="StlAllocator is derived std::allocator class that allows an Ion Allocator to be used for STL containe...">StlAllocator</a> holds an <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a>.  <a href="#aea07ae7e8734c2303603023e8b05639f">More...</a><br/></td></tr>
<tr class="separator:aea07ae7e8734c2303603023e8b05639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26387979cf6923d2902ab934ed9b26b4"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a26387979cf6923d2902ab934ed9b26b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a26387979cf6923d2902ab934ed9b26b4">operator!=</a> (const <a class="el" href="classion_1_1base_1_1_stl_allocator.html">StlAllocator</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="classion_1_1base_1_1_stl_allocator.html">StlAllocator</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a26387979cf6923d2902ab934ed9b26b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288196dbf5b78a993a3ada8b1aef9a7f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a288196dbf5b78a993a3ada8b1aef9a7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a288196dbf5b78a993a3ada8b1aef9a7f">operator==</a> (const <a class="el" href="classion_1_1base_1_1_stl_allocator.html">StlAllocator</a>&lt; <a class="el" href="class_t.html">T</a> &gt; &amp;lhs, const <a class="el" href="classion_1_1base_1_1_stl_allocator.html">StlAllocator</a>&lt; <a class="el" href="class_t.html">T</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a288196dbf5b78a993a3ada8b1aef9a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9910b3a68281c96360fa655acb549034"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9910b3a68281c96360fa655acb549034"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a9910b3a68281c96360fa655acb549034">operator!=</a> (const <a class="el" href="classion_1_1base_1_1_stl_allocator.html">StlAllocator</a>&lt; <a class="el" href="class_t.html">T</a> &gt; &amp;lhs, const <a class="el" href="classion_1_1base_1_1_stl_allocator.html">StlAllocator</a>&lt; <a class="el" href="class_t.html">T</a> &gt; &amp;rhs)</td></tr>
<tr class="separator:a9910b3a68281c96360fa655acb549034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1626e52b490f1f3502e1556ddeb270f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , int N1, int N2&gt; </td></tr>
<tr class="memitem:ac1626e52b490f1f3502e1556ddeb270f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ac1626e52b490f1f3502e1556ddeb270f">operator==</a> (const <a class="el" href="classion_1_1base_1_1_stl_inlined_allocator.html">StlInlinedAllocator</a>&lt; T1, N1 &gt; &amp;lhs, const <a class="el" href="classion_1_1base_1_1_stl_inlined_allocator.html">StlInlinedAllocator</a>&lt; T2, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac1626e52b490f1f3502e1556ddeb270f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classion_1_1base_1_1_stl_inlined_allocator.html" title="StlInlinedAllocator is a derived StlAllocator class that uses inlined storage for its first N element...">StlInlinedAllocator</a> instances are always unique because of inlined storage.  <a href="#ac1626e52b490f1f3502e1556ddeb270f">More...</a><br/></td></tr>
<tr class="separator:ac1626e52b490f1f3502e1556ddeb270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe380b5329e47a109984f479fc5534f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , int N1, int N2&gt; </td></tr>
<tr class="memitem:acfe380b5329e47a109984f479fc5534f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#acfe380b5329e47a109984f479fc5534f">operator!=</a> (const <a class="el" href="classion_1_1base_1_1_stl_inlined_allocator.html">StlInlinedAllocator</a>&lt; T1, N1 &gt; &amp;lhs, const <a class="el" href="classion_1_1base_1_1_stl_inlined_allocator.html">StlInlinedAllocator</a>&lt; T2, N2 &gt; &amp;rhs)</td></tr>
<tr class="separator:acfe380b5329e47a109984f479fc5534f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b6e9b03759c34b047cd097d65ce9dd"><td class="memItemLeft" align="right" valign="top">std::string ION_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aa9b6e9b03759c34b047cd097d65ce9dd">MimeBase64EncodeString</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:aa9b6e9b03759c34b047cd097d65ce9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mime base-64 encoded version of the passed string.  <a href="#aa9b6e9b03759c34b047cd097d65ce9dd">More...</a><br/></td></tr>
<tr class="separator:aa9b6e9b03759c34b047cd097d65ce9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e1cbcf213fe7c3440d3438fd4e44dc"><td class="memItemLeft" align="right" valign="top">std::string ION_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ac4e1cbcf213fe7c3440d3438fd4e44dc">EscapeString</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:ac4e1cbcf213fe7c3440d3438fd4e44dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an escaped version of the passed string.  <a href="#ac4e1cbcf213fe7c3440d3438fd4e44dc">More...</a><br/></td></tr>
<tr class="separator:ac4e1cbcf213fe7c3440d3438fd4e44dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b30d4aaf3eaa51bf72ad4b959cba04a"><td class="memItemLeft" align="right" valign="top">std::string ION_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a9b30d4aaf3eaa51bf72ad4b959cba04a">EscapeNewlines</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:a9b30d4aaf3eaa51bf72ad4b959cba04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with all newlines replaced by "\\n".  <a href="#a9b30d4aaf3eaa51bf72ad4b959cba04a">More...</a><br/></td></tr>
<tr class="separator:a9b30d4aaf3eaa51bf72ad4b959cba04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72ae4770776a5e356f99ff302fb4290"><td class="memTemplParams" colspan="2">template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:af72ae4770776a5e356f99ff302fb4290"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#af72ae4770776a5e356f99ff302fb4290">SplitStringHelper</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>, const std::string &amp;delimiters, std::vector&lt; std::string, Alloc &gt; *strings)</td></tr>
<tr class="separator:af72ae4770776a5e356f99ff302fb4290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6fa998a079374103813a83bb1f88da"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; ION_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a0e6fa998a079374103813a83bb1f88da">SplitString</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>, const std::string &amp;delimiters)</td></tr>
<tr class="memdesc:a0e6fa998a079374103813a83bb1f88da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into a vector of substrings, given a set of delimiter characters (expressed as a string).  <a href="#a0e6fa998a079374103813a83bb1f88da">More...</a><br/></td></tr>
<tr class="separator:a0e6fa998a079374103813a83bb1f88da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab797b404382b2057376e5813b4ddec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classion_1_1base_1_1_alloc_vector.html">AllocVector</a>&lt; std::string &gt; ION_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a7ab797b404382b2057376e5813b4ddec">SplitString</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>, const std::string &amp;delimiters, const <a class="el" href="namespaceion_1_1base.html#a43c6663b5bdd5e5839eba0729b613c28">AllocatorPtr</a> &amp;alloc)</td></tr>
<tr class="memdesc:a7ab797b404382b2057376e5813b4ddec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of SplitString taking an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a>.  <a href="#a7ab797b404382b2057376e5813b4ddec">More...</a><br/></td></tr>
<tr class="separator:a7ab797b404382b2057376e5813b4ddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac994311eb177697218ee933853894efa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; ION_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ac994311eb177697218ee933853894efa">SplitStringWithoutSkipping</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>, const std::string &amp;delimiters)</td></tr>
<tr class="memdesc:ac994311eb177697218ee933853894efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into a vector of substrings, given a set of delimiter characters (expressed as a string).  <a href="#ac994311eb177697218ee933853894efa">More...</a><br/></td></tr>
<tr class="separator:ac994311eb177697218ee933853894efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab02d07ebfaed9b3f3f60453168b62aa"><td class="memItemLeft" align="right" valign="top">ION_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aab02d07ebfaed9b3f3f60453168b62aa">UrlDecodeString</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:aab02d07ebfaed9b3f3f60453168b62aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a decoded version of a URL-encoded string.  <a href="#aab02d07ebfaed9b3f3f60453168b62aa">More...</a><br/></td></tr>
<tr class="separator:aab02d07ebfaed9b3f3f60453168b62aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf38f316ea978c6880b2bfe123c6ad4d"><td class="memItemLeft" align="right" valign="top">ION_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#adf38f316ea978c6880b2bfe123c6ad4d">UrlEncodeString</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:adf38f316ea978c6880b2bfe123c6ad4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a URL-encoded version of a string.  <a href="#adf38f316ea978c6880b2bfe123c6ad4d">More...</a><br/></td></tr>
<tr class="separator:adf38f316ea978c6880b2bfe123c6ad4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbd1fbe08f82dd46f056952c6807a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a> ION_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aafbd1fbe08f82dd46f056952c6807a4c">AreMultiLineStringsEqual</a> (const std::string &amp;s0, const std::string &amp;s1, <a class="el" href="classsize__t.html">size_t</a> *first_different_index, std::string *line0, std::string *line1, std::string *context0, std::string *context1)</td></tr>
<tr class="memdesc:aafbd1fbe08f82dd46f056952c6807a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be useful for comparing multi-line strings in tests.  <a href="#aafbd1fbe08f82dd46f056952c6807a4c">More...</a><br/></td></tr>
<tr class="separator:aafbd1fbe08f82dd46f056952c6807a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09599bdcfaa0226b1fc8052ed896928"><td class="memItemLeft" align="right" valign="top">int32 ION_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aa09599bdcfaa0226b1fc8052ed896928">StringToInt32</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:aa09599bdcfaa0226b1fc8052ed896928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts and returns an integral value from str.  <a href="#aa09599bdcfaa0226b1fc8052ed896928">More...</a><br/></td></tr>
<tr class="separator:aa09599bdcfaa0226b1fc8052ed896928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccc2a5ef64f45415f5367adae1635a4"><td class="memItemLeft" align="right" valign="top">ION_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a9ccc2a5ef64f45415f5367adae1635a4">CompareCaseInsensitive</a> (const std::string &amp;str1, const std::string &amp;str2)</td></tr>
<tr class="memdesc:a9ccc2a5ef64f45415f5367adae1635a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insensitive comparison of str1 and str2.  <a href="#a9ccc2a5ef64f45415f5367adae1635a4">More...</a><br/></td></tr>
<tr class="separator:a9ccc2a5ef64f45415f5367adae1635a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0419657dc7b58662e0a4f075cf04cf"><td class="memItemLeft" align="right" valign="top">ION_API <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aef0419657dc7b58662e0a4f075cf04cf">StartsWithCaseInsensitive</a> (const std::string &amp;target, const std::string &amp;start)</td></tr>
<tr class="memdesc:aef0419657dc7b58662e0a4f075cf04cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether target begins with start (case-insensitive).  <a href="#aef0419657dc7b58662e0a4f075cf04cf">More...</a><br/></td></tr>
<tr class="separator:aef0419657dc7b58662e0a4f075cf04cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272d19c05833939475841375894ec9a7"><td class="memItemLeft" align="right" valign="top">ION_API <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a272d19c05833939475841375894ec9a7">EndsWithCaseInsensitive</a> (const std::string &amp;target, const std::string &amp;end)</td></tr>
<tr class="memdesc:a272d19c05833939475841375894ec9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether target ends with end (case-insensitive).  <a href="#a272d19c05833939475841375894ec9a7">More...</a><br/></td></tr>
<tr class="separator:a272d19c05833939475841375894ec9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa815365f6d86640ca7bdffda239b125d"><td class="memItemLeft" align="right" valign="top">ION_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#aa815365f6d86640ca7bdffda239b125d">FindCaseInsensitive</a> (const std::string &amp;target, const std::string &amp;substr)</td></tr>
<tr class="memdesc:aa815365f6d86640ca7bdffda239b125d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insensitive version of std::string find.  <a href="#aa815365f6d86640ca7bdffda239b125d">More...</a><br/></td></tr>
<tr class="separator:aa815365f6d86640ca7bdffda239b125d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8e4928e10d0566632ba4ce1a7352b3"><td class="memItemLeft" align="right" valign="top">ION_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a2d8e4928e10d0566632ba4ce1a7352b3">WebSafeBase64Decode</a> (const std::string &amp;<a class="el" href="benchmarkutils_8cc.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:a2d8e4928e10d0566632ba4ce1a7352b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a Base64 encoded string.  <a href="#a2d8e4928e10d0566632ba4ce1a7352b3">More...</a><br/></td></tr>
<tr class="separator:a2d8e4928e10d0566632ba4ce1a7352b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa9facb22f72e8dfa468c0f1f59843a"><td class="memItemLeft" align="right" valign="top">ION_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a7fa9facb22f72e8dfa468c0f1f59843a">WebSafeBase64Encode</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a7fa9facb22f72e8dfa468c0f1f59843a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes a byte array using RFC 4648 base64url ('-' and '_' for 62 and 63, respectively, and no padding).  <a href="#a7fa9facb22f72e8dfa468c0f1f59843a">More...</a><br/></td></tr>
<tr class="separator:a7fa9facb22f72e8dfa468c0f1f59843a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee41efbc085e76d5fc124b6068664ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a6ee41efbc085e76d5fc124b6068664ad">QuoteString</a> (const std::string &amp;val)</td></tr>
<tr class="memdesc:a6ee41efbc085e76d5fc124b6068664ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a quoted and escaped version of the passed string.  <a href="#a6ee41efbc085e76d5fc124b6068664ad">More...</a><br/></td></tr>
<tr class="separator:a6ee41efbc085e76d5fc124b6068664ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31f7f8fcb3781c8cc6203d1f9289c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ab31f7f8fcb3781c8cc6203d1f9289c87">StartsWith</a> (const std::string &amp;target, const std::string &amp;start)</td></tr>
<tr class="memdesc:ab31f7f8fcb3781c8cc6203d1f9289c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether target begins with start.  <a href="#ab31f7f8fcb3781c8cc6203d1f9289c87">More...</a><br/></td></tr>
<tr class="separator:ab31f7f8fcb3781c8cc6203d1f9289c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d546dbcdea66767c448606dab690bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a60d546dbcdea66767c448606dab690bc">EndsWith</a> (const std::string &amp;target, const std::string &amp;end)</td></tr>
<tr class="memdesc:a60d546dbcdea66767c448606dab690bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether target ends with end.  <a href="#a60d546dbcdea66767c448606dab690bc">More...</a><br/></td></tr>
<tr class="separator:a60d546dbcdea66767c448606dab690bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef3c681990b56d7b86230ed3d758bd2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#abef3c681990b56d7b86230ed3d758bd2">JoinStrings</a> (const std::vector&lt; std::string &gt; &amp;strings, const std::string &amp;glue)</td></tr>
<tr class="memdesc:abef3c681990b56d7b86230ed3d758bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins the strings in the passed vector together with the passed glue.  <a href="#abef3c681990b56d7b86230ed3d758bd2">More...</a><br/></td></tr>
<tr class="separator:abef3c681990b56d7b86230ed3d758bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3560dbf0b6a4dee1effb6ad22498a796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a3560dbf0b6a4dee1effb6ad22498a796">RemovePrefix</a> (const std::string &amp;prefix, std::string *target)</td></tr>
<tr class="memdesc:a3560dbf0b6a4dee1effb6ad22498a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes prefix from the beginning of target if target starts with it.  <a href="#a3560dbf0b6a4dee1effb6ad22498a796">More...</a><br/></td></tr>
<tr class="separator:a3560dbf0b6a4dee1effb6ad22498a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd17d23d82442402527d123ce471f08f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#acd17d23d82442402527d123ce471f08f">RemoveSuffix</a> (const std::string &amp;suffix, std::string *target)</td></tr>
<tr class="memdesc:acd17d23d82442402527d123ce471f08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes suffix from the end of target if target ends with it.  <a href="#acd17d23d82442402527d123ce471f08f">More...</a><br/></td></tr>
<tr class="separator:acd17d23d82442402527d123ce471f08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574cae54cb0d3135ec26f71ec12b8a41"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a574cae54cb0d3135ec26f71ec12b8a41">ReplaceString</a> (const std::string &amp;search, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:a574cae54cb0d3135ec26f71ec12b8a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with all instances of from replaced with to.  <a href="#a574cae54cb0d3135ec26f71ec12b8a41">More...</a><br/></td></tr>
<tr class="separator:a574cae54cb0d3135ec26f71ec12b8a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441b93d33c1fb81fbc7fbe1a82c7a454"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a441b93d33c1fb81fbc7fbe1a82c7a454">TrimStartWhitespace</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:a441b93d33c1fb81fbc7fbe1a82c7a454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any whitespace characters at the beginning of the string.  <a href="#a441b93d33c1fb81fbc7fbe1a82c7a454">More...</a><br/></td></tr>
<tr class="separator:a441b93d33c1fb81fbc7fbe1a82c7a454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d822c2dfcece498fca34403c39e41d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#ae2d822c2dfcece498fca34403c39e41d">TrimEndWhitespace</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:ae2d822c2dfcece498fca34403c39e41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any whitespace characters at the end of the string.  <a href="#ae2d822c2dfcece498fca34403c39e41d">More...</a><br/></td></tr>
<tr class="separator:ae2d822c2dfcece498fca34403c39e41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2d6d60c240bddbccd3182c93b54e7b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a6e2d6d60c240bddbccd3182c93b54e7b">TrimStartAndEndWhitespace</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:a6e2d6d60c240bddbccd3182c93b54e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any whitespace characters at the beginning and end of the string.  <a href="#a6e2d6d60c240bddbccd3182c93b54e7b">More...</a><br/></td></tr>
<tr class="separator:a6e2d6d60c240bddbccd3182c93b54e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784cce06bb145ec4e00da13aa4ce2748"><td class="memTemplParams" colspan="2">template&lt;char expected&gt; </td></tr>
<tr class="memitem:a784cce06bb145ec4e00da13aa4ce2748"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a784cce06bb145ec4e00da13aa4ce2748">GetExpectedChar</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a784cce06bb145ec4e00da13aa4ce2748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream and returns the stream.  <a href="#a784cce06bb145ec4e00da13aa4ce2748">More...</a><br/></td></tr>
<tr class="separator:a784cce06bb145ec4e00da13aa4ce2748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d0267882489ac1c0f28473fd561b0a"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a92d0267882489ac1c0f28473fd561b0a">GetExpectedString</a> (std::istream &amp;in, const std::string &amp;expected)</td></tr>
<tr class="memdesc:a92d0267882489ac1c0f28473fd561b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read a string from the stream and returns the stream.  <a href="#a92d0267882489ac1c0f28473fd561b0a">More...</a><br/></td></tr>
<tr class="separator:a92d0267882489ac1c0f28473fd561b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9995e1c0f6b65eb9c4603075ed60b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ff9995e1c0f6b65eb9c4603075ed60b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a8ff9995e1c0f6b65eb9c4603075ed60b">AppendBytes</a> (std::string *s, const <a class="el" href="class_t.html">T</a> &amp;<a class="el" href="printer_8cc.html#a5c33da5929c9f2f9ef8d006d2350e6ec">value</a>)</td></tr>
<tr class="memdesc:a8ff9995e1c0f6b65eb9c4603075ed60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to append bytes to string.  <a href="#a8ff9995e1c0f6b65eb9c4603075ed60b">More...</a><br/></td></tr>
<tr class="separator:a8ff9995e1c0f6b65eb9c4603075ed60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4608f8e50b0898594bbef71d8a9a4ac5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsize__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceion_1_1base.html#a4608f8e50b0898594bbef71d8a9a4ac5">kInvalidIndex</a> = static_cast&lt;<a class="el" href="classsize__t.html">size_t</a>&gt;(-1)</td></tr>
<tr class="memdesc:a4608f8e50b0898594bbef71d8a9a4ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">kInvalidIndex is a size_t value that is very unlikely to be a valid index.  <a href="#a4608f8e50b0898594bbef71d8a9a4ac5">More...</a><br/></td></tr>
<tr class="separator:a4608f8e50b0898594bbef71d8a9a4ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classion_1_1base_1_1_enum_helper.html" title="}; static const char* kStrings[] = { &quot;Value1&quot;, &quot;Value2&quot;, &quot;Value3&quot; }; return EnumData&lt;Values&gt;(IndexMap...">EnumHelper</a> instantiations. These must be in the <a class="el" href="namespaceion_1_1base.html" title="EnumHelper instantiations. These must be in the ion::base namespace. ">ion::base</a> namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab2c3e3e952284ecabd82c1e941c93f28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a>&lt; <a class="el" href="classion_1_1base_1_1_allocation_size_tracker.html">AllocationSizeTracker</a> &gt; <a class="el" href="namespaceion_1_1base.html#ab2c3e3e952284ecabd82c1e941c93f28">ion::base::AllocationSizeTrackerPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedef for shared pointer to a <a class="el" href="classion_1_1base_1_1_allocation_size_tracker.html" title="AllocationSizeTracker is an abstract base class for objects that track memory. ">AllocationSizeTracker</a>. </p>

<p>Definition at line <a class="el" href="allocationsizetracker_8h_source.html#l00042">42</a> of file <a class="el" href="allocationsizetracker_8h_source.html">allocationsizetracker.h</a>.</p>

</div>
</div>
<a class="anchor" id="af44de58eef8b3c63067c79b5c73752a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a>&lt;<a class="el" href="classion_1_1base_1_1_allocation_tracker.html">AllocationTracker</a>&gt; <a class="el" href="namespaceion_1_1base.html#af44de58eef8b3c63067c79b5c73752a8">ion::base::AllocationTrackerPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedef for shared pointer to an <a class="el" href="classion_1_1base_1_1_allocation_tracker.html" title="AllocationTracker is an abstract base class for objects that track memory. ">AllocationTracker</a>. </p>

<p>Definition at line <a class="el" href="allocationtracker_8h_source.html#l00071">71</a> of file <a class="el" href="allocationtracker_8h_source.html">allocationtracker.h</a>.</p>

</div>
</div>
<a class="anchor" id="a43c6663b5bdd5e5839eba0729b613c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a>&lt;<a class="el" href="classion_1_1base_1_1_allocator.html">Allocator</a>&gt; <a class="el" href="namespaceion_1_1base.html#a43c6663b5bdd5e5839eba0729b613c28">ion::base::AllocatorPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="allocator_8h_source.html#l00051">51</a> of file <a class="el" href="allocator_8h_source.html">allocator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7fe5a4355abc33ba2c1d569043eaf8ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struction_1_1base_1_1_referent_ptr.html">ReferentPtr</a>&lt;<a class="el" href="classion_1_1base_1_1_call_list.html">CallList</a>&gt;::Type <a class="el" href="namespaceion_1_1base.html#a7fe5a4355abc33ba2c1d569043eaf8ca">ion::base::CallListPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="calllist_8h_source.html#l00105">105</a> of file <a class="el" href="calllist_8h_source.html">calllist.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9aea056fa3b5c46e3182f5427fb5f010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struction_1_1base_1_1_referent_ptr.html">base::ReferentPtr</a>&lt;<a class="el" href="classion_1_1base_1_1_data_container.html">DataContainer</a>&gt;::Type <a class="el" href="namespaceion_1_1base.html#a9aea056fa3b5c46e3182f5427fb5f010">ion::base::DataContainerPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="datacontainer_8h_source.html#l00038">38</a> of file <a class="el" href="datacontainer_8h_source.html">datacontainer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad99486dfa472f32bce7889ff0e3c54a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_weak_referent_ptr.html">base::WeakReferentPtr</a>&lt;<a class="el" href="classion_1_1base_1_1_data_container.html">DataContainer</a>&gt; <a class="el" href="namespaceion_1_1base.html#ad99486dfa472f32bce7889ff0e3c54a9">ion::base::DataContainerWeakPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="datacontainer_8h_source.html#l00040">40</a> of file <a class="el" href="datacontainer_8h_source.html">datacontainer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a56c4bcb7abfff8283044dc97409ffabc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a>&lt;<a class="el" href="classion_1_1base_1_1_full_allocation_tracker.html">FullAllocationTracker</a>&gt; <a class="el" href="namespaceion_1_1base.html#a56c4bcb7abfff8283044dc97409ffabc">ion::base::FullAllocationTrackerPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedef for shared pointer to a <a class="el" href="classion_1_1base_1_1_full_allocation_tracker.html" title="FullAllocationTracker is a derived AllocationTracker class that keeps track of all active allocations...">FullAllocationTracker</a>. </p>

<p>Definition at line <a class="el" href="fullallocationtracker_8h_source.html#l00074">74</a> of file <a class="el" href="fullallocationtracker_8h_source.html">fullallocationtracker.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa3d42b89a77ac34d6dff5e676032778b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_generic_lock_guard.html">GenericLockGuard</a>&lt;<a class="el" href="classion_1_1port_1_1_mutex.html">port::Mutex</a>&gt; <a class="el" href="namespaceion_1_1base.html#aa3d42b89a77ac34d6dff5e676032778b">ion::base::LockGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient typedefs for <a class="el" href="classion_1_1port_1_1_mutex.html" title="A Mutex is used to ensure that only one thread or process can access a block of code at one time...">ion::port::Mutex</a>. </p>

<p>Definition at line <a class="el" href="lockguards_8h_source.html#l00192">192</a> of file <a class="el" href="lockguards_8h_source.html">lockguards.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab470a11cceef7441df42bf6f489a69e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_generic_lock_guard.html">GenericLockGuard</a>&lt;<a class="el" href="classion_1_1base_1_1_read_lock.html">ReadLock</a>&gt; <a class="el" href="namespaceion_1_1base.html#ab470a11cceef7441df42bf6f489a69e5">ion::base::ReadGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient typedefs for <a class="el" href="classion_1_1base_1_1_read_write_lock.html" title="The ReadWriteLock class defines a non-promotable lock that is very fast when only readers try to obta...">ReadWriteLock</a>. </p>

<p>Definition at line <a class="el" href="lockguards_8h_source.html#l00202">202</a> of file <a class="el" href="lockguards_8h_source.html">lockguards.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9b3f0ff730a8e9b63c30211afc15894a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_generic_lock_guard.html">GenericLockGuard</a>&lt;<a class="el" href="classion_1_1base_1_1_spin_mutex.html">SpinMutex</a>&gt; <a class="el" href="namespaceion_1_1base.html#a9b3f0ff730a8e9b63c30211afc15894a">ion::base::SpinLockGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient typedefs for <a class="el" href="classion_1_1base_1_1_spin_mutex.html" title="SpinMutex exposes the same interface as ion::port::Mutex, but implements locking via a simple atomic ...">SpinMutex</a>. </p>

<p>Definition at line <a class="el" href="lockguards_8h_source.html#l00197">197</a> of file <a class="el" href="lockguards_8h_source.html">lockguards.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae1b0c7af7ff18e4a714b80651b6e7855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_generic_try_lock_guard.html">GenericTryLockGuard</a>&lt;<a class="el" href="classion_1_1base_1_1_spin_mutex.html">SpinMutex</a>&gt; <a class="el" href="namespaceion_1_1base.html#ae1b0c7af7ff18e4a714b80651b6e7855">ion::base::SpinTryLockGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lockguards_8h_source.html#l00199">199</a> of file <a class="el" href="lockguards_8h_source.html">lockguards.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6705573b0cb8241baede450b5e812f97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_generic_unlock_guard.html">GenericUnlockGuard</a>&lt;<a class="el" href="classion_1_1base_1_1_spin_mutex.html">SpinMutex</a>&gt; <a class="el" href="namespaceion_1_1base.html#a6705573b0cb8241baede450b5e812f97">ion::base::SpinUnlockGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lockguards_8h_source.html#l00198">198</a> of file <a class="el" href="lockguards_8h_source.html">lockguards.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa32c09756509bc7d623f6d5e5730607f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_generic_try_lock_guard.html">GenericTryLockGuard</a>&lt;<a class="el" href="classion_1_1port_1_1_mutex.html">port::Mutex</a>&gt; <a class="el" href="namespaceion_1_1base.html#aa32c09756509bc7d623f6d5e5730607f">ion::base::TryLockGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lockguards_8h_source.html#l00194">194</a> of file <a class="el" href="lockguards_8h_source.html">lockguards.h</a>.</p>

</div>
</div>
<a class="anchor" id="aec6d478dc70549e7bad6d824b5a827fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_generic_unlock_guard.html">GenericUnlockGuard</a>&lt;<a class="el" href="classion_1_1port_1_1_mutex.html">port::Mutex</a>&gt; <a class="el" href="namespaceion_1_1base.html#aec6d478dc70549e7bad6d824b5a827fc">ion::base::UnlockGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lockguards_8h_source.html#l00193">193</a> of file <a class="el" href="lockguards_8h_source.html">lockguards.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa710835f4c8519208e8640e83e9a95db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classion_1_1base_1_1_generic_lock_guard.html">GenericLockGuard</a>&lt;<a class="el" href="classion_1_1base_1_1_write_lock.html">WriteLock</a>&gt; <a class="el" href="namespaceion_1_1base.html#aa710835f4c8519208e8640e83e9a95db">ion::base::WriteGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lockguards_8h_source.html#l00203">203</a> of file <a class="el" href="lockguards_8h_source.html">lockguards.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a5fca7f9340dcefae18f258053de7757c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceion_1_1base.html#a5fca7f9340dcefae18f258053de7757c">ion::base::AllocationLifetime</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All memory allocated within Ion uses an <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> chosen based on the predicted lifetime of the target object. </p>
<p>This enum defines the lifetime categories. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a5fca7f9340dcefae18f258053de7757ca0e572cccc7b2f48ced01134b3acc3396"></a>kShortTerm</em>&#160;</td><td class="fielddoc">
<p>kShortTerm is used for objects that are very transient in nature, such as scratch memory used to compute a result. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5fca7f9340dcefae18f258053de7757caf03f24745ec5729b9c4ba500f7ff654d"></a>kMediumTerm</em>&#160;</td><td class="fielddoc">
<p>kMediumTerm is used for objects that don't fall into the kShortTerm or kLongTerm categories. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5fca7f9340dcefae18f258053de7757cae13e720cb817ed225d324290a0acd4f0"></a>kLongTerm</em>&#160;</td><td class="fielddoc">
<p>kLongTerm is used for objects that have persistent lifetimes, such as managers. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="allocator_8h_source.html#l00033">33</a> of file <a class="el" href="allocator_8h_source.html">allocator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8ff9995e1c0f6b65eb9c4603075ed60b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ion::base::AppendBytes </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to append bytes to string. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00253">253</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>References <a class="el" href="benchmarkutils_8cc_source.html#l00063">value</a>.</p>

<p>Referenced by <a class="el" href="tracerecorder_8cc_source.html#l00263">ion::profile::TraceRecorder::DumpTrace()</a>, and <a class="el" href="calltracemanager_8cc_source.html#l00386">ion::profile::CallTraceManager::SnapshotCallTraces()</a>.</p>

</div>
</div>
<a class="anchor" id="aafbd1fbe08f82dd46f056952c6807a4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API <a class="el" href="classbool.html">bool</a> ion::base::AreMultiLineStringsEqual </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsize__t.html">size_t</a> *&#160;</td>
          <td class="paramname"><em>first_different_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>line0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>line1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>context0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>context1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can be useful for comparing multi-line strings in tests. </p>
<p>If the two multi-line strings are equal, it just returns true. Otherwise, it splits the strings by newlines and determines the first line that differs. It sets first_different_index to the index (starting a 0) of that line, sets line0 and line1 to the contents of those lines in the two strings, sets context0 and context1 to be the lines near where the difference was found, and returns false. Any of the out-parameters may be NULL. </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00267">267</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="stringutils_8cc_source.html#l00187">SplitString()</a>, and <a class="el" href="benchmarkutils_8cc_source.html#l00049">str</a>.</p>

</div>
</div>
<a class="anchor" id="a9ccc2a5ef64f45415f5367adae1635a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API int ion::base::CompareCaseInsensitive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Case-insensitive comparison of str1 and str2. </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00335">335</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9cab5e1cde59e83842461ad4a7835342"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classion_1_1base_1_1_shared_ptr.html">SharedPtr</a>&lt;To&gt; ion::base::DynamicPtrCast </td>
          <td>(</td>
          <td class="paramtype">const SharedPtr&lt; From &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows casting SharedPtrs down a type hierarchy. </p>

<p>Definition at line <a class="el" href="sharedptr_8h_source.html#l00191">191</a> of file <a class="el" href="sharedptr_8h_source.html">sharedptr.h</a>.</p>

<p>References <a class="el" href="sharedptr_8h_source.html#l00089">ion::base::SharedPtr&lt; T &gt;::Get()</a>.</p>

</div>
</div>
<a class="anchor" id="a60d546dbcdea66767c448606dab690bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::EndsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether target ends with end. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00081">81</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>Referenced by <a class="el" href="calltracehandler_8cc_source.html#l00041">ion::remote::CallTraceHandler::HandleRequest()</a>, <a class="el" href="resourcehandler_8cc_source.html#l00965">ion::remote::ResourceHandler::HandleRequest()</a>, <a class="el" href="settinghandler_8cc_source.html#l00093">ion::remote::SettingHandler::HandleRequest()</a>, <a class="el" href="tracinghandler_8cc_source.html#l00331">ion::remote::TracingHandler::HandleRequest()</a>, <a class="el" href="nodegraphhandler_8cc_source.html#l00066">ion::remote::NodeGraphHandler::HandleRequest()</a>, <a class="el" href="shaderhandler_8cc_source.html#l00372">ion::remote::ShaderHandler::HandleRequest()</a>, <a class="el" href="stringutils_8h_source.html#l00113">RemoveSuffix()</a>, and <a class="el" href="setting_8h_source.html#l00117">ion::base::SettingGroup::SettingGroup()</a>.</p>

</div>
</div>
<a class="anchor" id="a272d19c05833939475841375894ec9a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API <a class="el" href="classbool.html">bool</a> ion::base::EndsWithCaseInsensitive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether target ends with end (case-insensitive). </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00353">353</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9b30d4aaf3eaa51bf72ad4b959cba04a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API std::string ion::base::EscapeNewlines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string with all newlines replaced by "\\n". </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00152">152</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="calltracemanager_8cc_source.html#l00042">length</a>.</p>

</div>
</div>
<a class="anchor" id="ac4e1cbcf213fe7c3440d3438fd4e44dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API std::string ion::base::EscapeString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an escaped version of the passed string. </p>
<p>For example: EscapeString("\aBell\bNew "Line<br/>
") returns "\aBell\bNew "Line\n"; </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00105">105</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="calltracemanager_8cc_source.html#l00042">length</a>.</p>

<p>Referenced by <a class="el" href="stringutils_8h_source.html#l00069">QuoteString()</a>, and <a class="el" href="serialize_8h_source.html#l00241">ValueToString()</a>.</p>

</div>
</div>
<a class="anchor" id="aa815365f6d86640ca7bdffda239b125d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API int ion::base::FindCaseInsensitive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Case-insensitive version of std::string find. </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00359">359</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad4c656c70a6ae096b214f19095c9b00b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API <a class="el" href="classion_1_1port_1_1_log_entry_writer.html">port::LogEntryWriter</a> * ion::base::GetDefaultLogEntryWriter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log-writer that messages will be logged to if if another is not explicitly specified via <a class="el" href="namespaceion_1_1base.html#a955bfd777c3064212e886ec9bde1a670" title="Public functions. ">SetLogEntryWriter()</a>. </p>

<p>Definition at line <a class="el" href="base_2logging_8cc_source.html#l00197">197</a> of file <a class="el" href="base_2logging_8cc_source.html">logging.cc</a>.</p>

<p>References <a class="el" href="logging__android_8cc_source.html#l00087">ion::port::CreateDefaultLogEntryWriter()</a>, and <a class="el" href="staticsafedeclare_8h_source.html#l00122">ION_DECLARE_SAFE_STATIC_POINTER_WITH_CONSTRUCTOR</a>.</p>

<p>Referenced by <a class="el" href="base_2logging_8cc_source.html#l00192">GetLogEntryWriter()</a>, and <a class="el" href="staticsafedeclare_8cc_source.html#l00025">ion::base::StaticDeleterDeleter::StaticDeleterDeleter()</a>.</p>

</div>
</div>
<a class="anchor" id="a784cce06bb145ec4e00da13aa4ce2748"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;char expected&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; ion::base::GetExpectedChar </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single character from the stream and returns the stream. </p>
<p>If the read character does not match the expected char, then this ungets the character and sets the stream's failure bit. This function can be used in various ways, such as in a boolean test (istream automatically casts to bool), or inline with the &gt;&gt; operator. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00215">215</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00165">ion::math::operator&gt;&gt;()</a>, <a class="el" href="vector_8h_source.html#l00095">ion::math::VectorBase&lt; Dimension, T &gt;::Read()</a>, <a class="el" href="fieldofview_8h_source.html#l00437">ion::math::FieldOfView&lt; T &gt;::Read()</a>, and <a class="el" href="serialize_8h_source.html#l00115">StringToStlContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="a92d0267882489ac1c0f28473fd561b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; ion::base::GetExpectedString </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to read a string from the stream and returns the stream. </p>
<p>If the stream does not start with the expected string, then this ungets the read portion of the string and sets the stream's failure bit. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00228">228</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>References <a class="el" href="calltracemanager_8cc_source.html#l00042">length</a>.</p>

<p>Referenced by <a class="el" href="angle_8h_source.html#l00135">ion::math::operator&gt;&gt;()</a>, and <a class="el" href="fieldofview_8h_source.html#l00437">ion::math::FieldOfView&lt; T &gt;::Read()</a>.</p>

</div>
</div>
<a class="anchor" id="a9bcfa31bd13cbf539845f73f0e49ceb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API <a class="el" href="classion_1_1port_1_1_log_entry_writer.html">port::LogEntryWriter</a> * ion::base::GetLogEntryWriter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log-writer that messages are currently logged to. </p>

<p>Definition at line <a class="el" href="base_2logging_8cc_source.html#l00192">192</a> of file <a class="el" href="base_2logging_8cc_source.html">logging.cc</a>.</p>

<p>References <a class="el" href="base_2logging_8cc_source.html#l00197">GetDefaultLogEntryWriter()</a>.</p>

<p>Referenced by <a class="el" href="base_2logging_8cc_source.html#l00111">ion::base::logging_internal::Logger::~Logger()</a>.</p>

</div>
</div>
<a class="anchor" id="a12d3865496a66b90d413b60dadc40407"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnumType ion::base::InvalidEnumValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceion_1_1base.html#a12d3865496a66b90d413b60dadc40407" title="InvalidEnumValue() returns an invalid enum value, assuming that -1 is not a valid value...">InvalidEnumValue()</a> returns an invalid enum value, assuming that -1 is not a valid value. </p>
<p>This can be used for initializing enum variables or for testing. </p>

<p>Definition at line <a class="el" href="invalid_8h_source.html#l00047">47</a> of file <a class="el" href="invalid_8h_source.html">invalid.h</a>.</p>

</div>
</div>
<a class="anchor" id="a62eaa5f45ca6b9f446ca128679860ead"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::IsInvalidReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceion_1_1base.html#a62eaa5f45ca6b9f446ca128679860ead" title="IsInvalidReference() returns true if a passed const reference of type T has an address of InvalidRefe...">IsInvalidReference()</a> returns true if a passed const reference of type <a class="el" href="class_t.html">T</a> has an address of InvalidReference&lt;T&gt;(). </p>
<p>A return value of false does not guarantee that a reference is valid, just that it is not an InvalidReference. </p>

<p>Definition at line <a class="el" href="invalid_8h_source.html#l00041">41</a> of file <a class="el" href="invalid_8h_source.html">invalid.h</a>.</p>

<p>Referenced by <a class="el" href="fontmanager_8cc_source.html#l00069">ion::text::FontManager::AddFontFromZipasset()</a>, <a class="el" href="font_8cc_source.html#l00081">ion::text::Font::AddGlyph()</a>, <a class="el" href="builder_8cc_source.html#l00148">ion::text::Builder::Build()</a>, <a class="el" href="shapeutils_8cc_source.html#l01236">ion::gfxutils::BuildWireframeIndexBuffer()</a>, <a class="el" href="font_8cc_source.html#l00095">ion::text::Font::CacheSdfGrids()</a>, <a class="el" href="freetypefontutils_8cc_source.html#l00102">ion::text::ComputeTextSize()</a>, <a class="el" href="graphicsmanager_8cc_source.html#l00370">ion::gfx::GraphicsManager::GetCapabilityValue()</a>, <a class="el" href="zipassetmanager_8cc_source.html#l00164">ion::base::ZipAssetManager::GetFileDataNoCache()</a>, <a class="el" href="zipassetmanager_8cc_source.html#l00147">ion::base::ZipAssetManager::GetFileDataPtr()</a>, <a class="el" href="freetypefont_8cc_source.html#l00868">ion::text::FreeTypeFont::GetGlyphMetrics()</a>, <a class="el" href="fontimage_8cc_source.html#l00452">ion::text::FontImage::GetTextureCoords()</a>, <a class="el" href="calltracehandler_8cc_source.html#l00041">ion::remote::CallTraceHandler::HandleRequest()</a>, <a class="el" href="resourcehandler_8cc_source.html#l00965">ion::remote::ResourceHandler::HandleRequest()</a>, <a class="el" href="settinghandler_8cc_source.html#l00093">ion::remote::SettingHandler::HandleRequest()</a>, <a class="el" href="tracinghandler_8cc_source.html#l00331">ion::remote::TracingHandler::HandleRequest()</a>, <a class="el" href="nodegraphhandler_8cc_source.html#l00066">ion::remote::NodeGraphHandler::HandleRequest()</a>, <a class="el" href="shaderhandler_8cc_source.html#l00372">ion::remote::ShaderHandler::HandleRequest()</a>, <a class="el" href="fontimage_8h_source.html#l00101">ion::text::FontImage::HasAllGlyphs()</a>, <a class="el" href="fontimage_8h_source.html#l00111">ion::text::FontImage::HasGlyph()</a>, <a class="el" href="attributearray_8h_source.html#l00082">ion::gfx::AttributeArray::IsBufferAttributeEnabled()</a>, <a class="el" href="zipassetmanager_8cc_source.html#l00223">ion::base::ZipAssetManager::SaveFileData()</a>, and <a class="el" href="builder_8cc_source.html#l00246">ion::text::Builder::StoreGlyphVertices()</a>.</p>

</div>
</div>
<a class="anchor" id="abef3c681990b56d7b86230ed3d758bd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::JoinStrings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>glue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Joins the strings in the passed vector together with the passed glue. </p>
<p>The glue may be empty, in which case the strings are simply concatenated. If strings contains no strings then an empty string is returned. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00089">89</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>Referenced by <a class="el" href="graphicsmanager_8cc_source.html#l00447">ion::gfx::GraphicsManager::InitGlInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9b6e9b03759c34b047cd097d65ce9dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API std::string ion::base::MimeBase64EncodeString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mime base-64 encoded version of the passed string. </p>
<p>Output is padded with ='s (see <a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a>). </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00057">57</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="base_2logging_8h_source.html#l00332">DCHECK_EQ</a>, and <a class="el" href="calltracemanager_8cc_source.html#l00042">length</a>.</p>

</div>
</div>
<a class="anchor" id="a26387979cf6923d2902ab934ed9b26b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StlAllocator&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StlAllocator&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stlallocator_8h_source.html#l00242">242</a> of file <a class="el" href="stlallocator_8h_source.html">stlallocator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9910b3a68281c96360fa655acb549034"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StlAllocator&lt; <a class="el" href="class_t.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StlAllocator&lt; <a class="el" href="class_t.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stlallocator_8h_source.html#l00252">252</a> of file <a class="el" href="stlallocator_8h_source.html">stlallocator.h</a>.</p>

<p>References <a class="el" href="stlallocator_8h_source.html#l00054">ion::base::StlAllocator&lt; T &gt;::GetAllocator()</a>.</p>

</div>
</div>
<a class="anchor" id="acfe380b5329e47a109984f479fc5534f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , int N1, int N2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::operator!= </td>
          <td>(</td>
          <td class="paramtype">const StlInlinedAllocator&lt; T1, N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StlInlinedAllocator&lt; T2, N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stlallocator_8h_source.html#l00264">264</a> of file <a class="el" href="stlallocator_8h_source.html">stlallocator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a63e51b10be4e4145652f551a0f77a01b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ion::base::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DateTime &amp;&#160;</td>
          <td class="paramname"><em>dtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="datetime_8cc_source.html#l00361">361</a> of file <a class="el" href="datetime_8cc_source.html">datetime.cc</a>.</p>

<p>References <a class="el" href="datetime_8cc_source.html#l00310">ion::base::DateTime::ToString()</a>.</p>

</div>
</div>
<a class="anchor" id="aea07ae7e8734c2303603023e8b05639f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::operator== </td>
          <td>(</td>
          <td class="paramtype">const StlAllocator&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StlAllocator&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each <a class="el" href="classion_1_1base_1_1_stl_allocator.html" title="StlAllocator is derived std::allocator class that allows an Ion Allocator to be used for STL containe...">StlAllocator</a> holds an <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a>. </p>
<p><a class="el" href="classion_1_1base_1_1_stl_allocator.html" title="StlAllocator is derived std::allocator class that allows an Ion Allocator to be used for STL containe...">StlAllocator</a> objects are only equal if they refer to the same <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a> and are allocating the same type <a class="el" href="class_t.html">T</a>. </p>

<p>Definition at line <a class="el" href="stlallocator_8h_source.html#l00237">237</a> of file <a class="el" href="stlallocator_8h_source.html">stlallocator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a288196dbf5b78a993a3ada8b1aef9a7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::operator== </td>
          <td>(</td>
          <td class="paramtype">const StlAllocator&lt; <a class="el" href="class_t.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StlAllocator&lt; <a class="el" href="class_t.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stlallocator_8h_source.html#l00247">247</a> of file <a class="el" href="stlallocator_8h_source.html">stlallocator.h</a>.</p>

<p>References <a class="el" href="stlallocator_8h_source.html#l00054">ion::base::StlAllocator&lt; T &gt;::GetAllocator()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1626e52b490f1f3502e1556ddeb270f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , int N1, int N2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::operator== </td>
          <td>(</td>
          <td class="paramtype">const StlInlinedAllocator&lt; T1, N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StlInlinedAllocator&lt; T2, N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classion_1_1base_1_1_stl_inlined_allocator.html" title="StlInlinedAllocator is a derived StlAllocator class that uses inlined storage for its first N element...">StlInlinedAllocator</a> instances are always unique because of inlined storage. </p>

<p>Definition at line <a class="el" href="stlallocator_8h_source.html#l00258">258</a> of file <a class="el" href="stlallocator_8h_source.html">stlallocator.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab68791b943a463bbfce5b44945311842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; ion::base::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DateTime &amp;&#160;</td>
          <td class="paramname"><em>dtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="datetime_8cc_source.html#l00516">516</a> of file <a class="el" href="datetime_8cc_source.html">datetime.cc</a>.</p>

<p>References <a class="el" href="datetime_8cc_source.html#l00366">ion::base::DateTime::FromString()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ee41efbc085e76d5fc124b6068664ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::QuoteString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a quoted and escaped version of the passed string. </p>
<p>For example: QuoteString("Hello") returns "\"Hello"". </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00069">69</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>References <a class="el" href="stringutils_8cc_source.html#l00105">EscapeString()</a>.</p>

</div>
</div>
<a class="anchor" id="a3560dbf0b6a4dee1effb6ad22498a796"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::RemovePrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes prefix from the beginning of target if target starts with it. </p>
<p>Returns whether prefix was removed. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00102">102</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>References <a class="el" href="stringutils_8h_source.html#l00076">StartsWith()</a>.</p>

<p>Referenced by <a class="el" href="zipassetmanager_8cc_source.html#l00050">ion::base::ZipAssetManager::RegisterAssetData()</a>, and <a class="el" href="setting_8h_source.html#l00121">ion::base::SettingGroup::SettingGroup()</a>.</p>

</div>
</div>
<a class="anchor" id="acd17d23d82442402527d123ce471f08f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::RemoveSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes suffix from the end of target if target ends with it. </p>
<p>Returns whether suffix was removed. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00113">113</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>References <a class="el" href="stringutils_8h_source.html#l00081">EndsWith()</a>.</p>

<p>Referenced by <a class="el" href="httpserver_8cc_source.html#l00714">ion::remote::HttpServer::RegisterHandler()</a>, and <a class="el" href="setting_8h_source.html#l00117">ion::base::SettingGroup::SettingGroup()</a>.</p>

</div>
</div>
<a class="anchor" id="a574cae54cb0d3135ec26f71ec12b8a41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ReplaceString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string with all instances of from replaced with to. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00122">122</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa50433725be84a02efd91a7d9a583314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API void ion::base::RestoreDefaultBreakHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the default break handler (port::BreakAndAbort). </p>

<p>Definition at line <a class="el" href="base_2logging_8cc_source.html#l00211">211</a> of file <a class="el" href="base_2logging_8cc_source.html">logging.cc</a>.</p>

<p>References <a class="el" href="break_8cc_source.html#l00141">ion::port::BreakOrAbort()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d63ed65684a747bf5d05515aec36a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API void ion::base::SetBreakHandler </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a custom break handler that gets invoked by Logger::CheckMessage. </p>
<p>If break_handler is an empty function (e.g. a std::function&lt;void()&gt; without any function assigned to it), fatal errors will not invoke any break handler and will not abort program execution. </p>

<p>Definition at line <a class="el" href="base_2logging_8cc_source.html#l00205">205</a> of file <a class="el" href="base_2logging_8cc_source.html">logging.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a955bfd777c3064212e886ec9bde1a670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API void ion::base::SetLogEntryWriter </td>
          <td>(</td>
          <td class="paramtype">port::LogEntryWriter *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public functions. </p>
<p>See <a class="el" href="classion_1_1port_1_1_log_entry_writer.html" title="Abstract class which can be overridden to integrate Ion logging with other logging systems...">ion::port::LogEntryWriter</a>, an abstract class which can be overridden to integrate Ion Logging with other logging systems.</p>
<p>Sets the log-writer to log messages to, instead of the default for the current platform (passing NULL causes the default writer to be used). It is assumed that the writer's lifetime is long enough to process all subsequent messages. </p>

<p>Definition at line <a class="el" href="base_2logging_8cc_source.html#l00188">188</a> of file <a class="el" href="base_2logging_8cc_source.html">logging.cc</a>.</p>

<p>Referenced by <a class="el" href="logchecker_8cc_source.html#l00025">ion::base::LogChecker::LogChecker()</a>, <a class="el" href="nulllogentrywriter_8h_source.html#l00051">ion::base::NullLogEntryWriter::NullLogEntryWriter()</a>, <a class="el" href="logchecker_8cc_source.html#l00030">ion::base::LogChecker::~LogChecker()</a>, and <a class="el" href="nulllogentrywriter_8h_source.html#l00054">ion::base::NullLogEntryWriter::~NullLogEntryWriter()</a>.</p>

</div>
</div>
<a class="anchor" id="ad93f0b9bc825991bd2aa5d33245e0543"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SettingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ion::base::SetTypeDescriptorForType </td>
          <td>(</td>
          <td class="paramtype">SettingType *&#160;</td>
          <td class="paramname"><em>setting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the type descriptor string of a setting based on its type. </p>
<p>The unspecialized version of this function leaves the string untouched (empty). </p>

<p>Definition at line <a class="el" href="setting_8h_source.html#l00368">368</a> of file <a class="el" href="setting_8h_source.html">setting.h</a>.</p>

<p>Referenced by <a class="el" href="setting_8h_source.html#l00159">ion::base::Setting&lt; bool &gt;::Setting()</a>, and <a class="el" href="setting_8h_source.html#l00231">ion::base::Setting&lt; std::atomic&lt; T &gt; &gt;::Setting()</a>.</p>

</div>
</div>
<a class="anchor" id="a814b66b3576191b9dd9863ea5e65ec66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ion::base::SetTypeDescriptorForType </td>
          <td>(</td>
          <td class="paramtype">Setting&lt; <a class="el" href="classbool.html">bool</a> &gt; *&#160;</td>
          <td class="paramname"><em>setting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boolean settings set the descriptor to "bool". </p>

<p>Definition at line <a class="el" href="setting_8h_source.html#l00373">373</a> of file <a class="el" href="setting_8h_source.html">setting.h</a>.</p>

<p>References <a class="el" href="setting_8h_source.html#l00065">ion::base::SettingBase::SetTypeDescriptor()</a>.</p>

</div>
</div>
<a class="anchor" id="aca144f74762a940cea0c89061339552a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ion::base::SetTypeDescriptorForType </td>
          <td>(</td>
          <td class="paramtype">Setting&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt; *&#160;</td>
          <td class="paramname"><em>setting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="setting_8h_source.html#l00378">378</a> of file <a class="el" href="setting_8h_source.html">setting.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0e6fa998a079374103813a83bb1f88da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API std::vector&lt; std::string &gt; ion::base::SplitString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into a vector of substrings, given a set of delimiter characters (expressed as a string). </p>
<p>Empty strings are skipped, as are consecutive delimiters.</p>
<p>For example: SplitString(" Hello\t    there \t \n", " \t\n"); will return a vector containing two strings, "Hello" and "there". </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00187">187</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="stringutils_8cc_source.html#l00170">SplitStringHelper()</a>.</p>

<p>Referenced by <a class="el" href="stringutils_8cc_source.html#l00267">AreMultiLineStringsEqual()</a>, <a class="el" href="freetypefont_8cc_source.html#l00839">ion::text::FreeTypeFont::BuildLayout()</a>, <a class="el" href="graphicsmanager_8cc_source.html#l00621">ion::gfx::GraphicsManager::EnableFunctionGroupIfAvailable()</a>, <a class="el" href="logchecker_8cc_source.html#l00089">ion::base::LogChecker::GetAllMessages()</a>, <a class="el" href="logchecker_8cc_source.html#l00040">ion::base::LogChecker::HasMessage()</a>, <a class="el" href="logchecker_8cc_source.html#l00069">ion::base::LogChecker::HasNoMessage()</a>, <a class="el" href="zipassetmanager_8cc_source.html#l00050">ion::base::ZipAssetManager::RegisterAssetData()</a>, and <a class="el" href="httpclient_8cc_source.html#l00121">ion::remote::HttpClient::Url::Set()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ab797b404382b2057376e5813b4ddec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API <a class="el" href="classion_1_1base_1_1_alloc_vector.html">AllocVector</a>&lt; std::string &gt; ion::base::SplitString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AllocatorPtr &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of SplitString taking an Ion <a class="el" href="classion_1_1base_1_1_allocator.html" title="Allocator is an abstract base class for a memory allocator used for Ion objects derived from Allocata...">Allocator</a>. </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00194">194</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="stringutils_8cc_source.html#l00170">SplitStringHelper()</a>.</p>

</div>
</div>
<a class="anchor" id="af72ae4770776a5e356f99ff302fb4290"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ion::base::SplitStringHelper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string, Alloc &gt; *&#160;</td>
          <td class="paramname"><em>strings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00170">170</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>Referenced by <a class="el" href="stringutils_8cc_source.html#l00187">SplitString()</a>.</p>

</div>
</div>
<a class="anchor" id="ac994311eb177697218ee933853894efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API std::vector&lt; std::string &gt; ion::base::SplitStringWithoutSkipping </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into a vector of substrings, given a set of delimiter characters (expressed as a string). </p>
<p>Empty strings are skipped, but consecutive delimiters are not.</p>
<p>For example: SplitStringWithoutSkipping("Hello\n\nthere\n", "\n"); will return a vector containing three strings, "Hello", "", and "there". </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00202">202</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="calltracemanager_8cc_source.html#l00042">length</a>.</p>

</div>
</div>
<a class="anchor" id="ab31f7f8fcb3781c8cc6203d1f9289c87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StartsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether target begins with start. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00076">76</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>Referenced by <a class="el" href="tracecallextractor_8cc_source.html#l00046">ion::gfx::TraceCallExtractor::GetCountOf()</a>, <a class="el" href="visual_8cc_source.html#l00964">ion::portgfx::Visual::GetGlVersion()</a>, <a class="el" href="tracecallextractor_8cc_source.html#l00055">ion::gfx::TraceCallExtractor::GetNthIndexOf()</a>, <a class="el" href="httpserver_8cc_source.html#l00695">ion::remote::HttpServer::GetUriData()</a>, <a class="el" href="shaderhandler_8cc_source.html#l00372">ion::remote::ShaderHandler::HandleRequest()</a>, <a class="el" href="zipassetmanager_8cc_source.html#l00050">ion::base::ZipAssetManager::RegisterAssetData()</a>, <a class="el" href="stringutils_8h_source.html#l00102">RemovePrefix()</a>, <a class="el" href="setting_8h_source.html#l00121">ion::base::SettingGroup::SettingGroup()</a>, and <a class="el" href="tracinghelper_8cc_source.html#l00825">ion::gfx::TracingHelper::ToString()</a>.</p>

</div>
</div>
<a class="anchor" id="aef0419657dc7b58662e0a4f075cf04cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API <a class="el" href="classbool.html">bool</a> ion::base::StartsWithCaseInsensitive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether target begins with start (case-insensitive). </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00347">347</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a2f992726c8861db59358d3793568a95e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::StlContainerToString </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes an STL container to a string. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00263">263</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00209">ValueToString()</a>.</p>

<p>Referenced by <a class="el" href="serialize_8h_source.html#l00280">ValueToString()</a>.</p>

</div>
</div>
<a class="anchor" id="aa09599bdcfaa0226b1fc8052ed896928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API int32 ion::base::StringToInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts and returns an integral value from str. </p>
<p>If str does not start with an integer then returns 0. </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00328">328</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="benchmarkutils_8cc_source.html#l00063">value</a>.</p>

<p>Referenced by <a class="el" href="datetime_8cc_source.html#l00896">ion::base::DateTime::ParseYMString()</a>, and <a class="el" href="httpclient_8cc_source.html#l00121">ion::remote::HttpClient::Url::Set()</a>.</p>

</div>
</div>
<a class="anchor" id="a3bfabaf1f67063167064bb2663cd3fdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToStlContainer </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a STL container from a stream. </p>
<p>If any errors occur then the stream's failure bit is set and val is not modified. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00115">115</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="stringutils_8h_source.html#l00215">GetExpectedChar()</a>, <a class="el" href="serialize_8h_source.html#l00045">StringToValue()</a>, and <a class="el" href="benchmarkutils_8cc_source.html#l00063">value</a>.</p>

<p>Referenced by <a class="el" href="serialize_8h_source.html#l00147">StringToValue()</a>.</p>

</div>
</div>
<a class="anchor" id="afc5ce99df0e50584507f4c04cf4ddb42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t.html">T</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This file defines two public functions: <a class="el" href="namespaceion_1_1base.html#afc5ce99df0e50584507f4c04cf4ddb42" title="This file defines two public functions: StringToValue() and ValueToString(). ">StringToValue()</a> and <a class="el" href="namespaceion_1_1base.html#a38945775ca691f4c7e2d186567037995" title="ValueToString. ">ValueToString()</a>. </p>
<p>These functions serialize data types to std::strings and from std::istringstreams, and also support most STL containers. Serializing custom types requires defining only the insertion and extraction operators (&lt;&lt; and &gt;&gt;) StringToValue </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00045">45</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="benchmarkutils_8cc_source.html#l00063">value</a>.</p>

<p>Referenced by <a class="el" href="setting_8h_source.html#l00190">ion::base::Setting&lt; bool &gt;::FromString()</a>, <a class="el" href="setting_8h_source.html#l00264">ion::base::Setting&lt; std::atomic&lt; T &gt; &gt;::FromString()</a>, <a class="el" href="serialize_8h_source.html#l00115">StringToStlContainer()</a>, and <a class="el" href="serialize_8h_source.html#l00097">StringToValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a11b7613ccc25ea0e8426a295adb76e51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialize for bools. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00058">58</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="benchmarkutils_8cc_source.html#l00063">value</a>.</p>

</div>
</div>
<a class="anchor" id="a7fb3b55167510d458eecc1143be224c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a> &gt; *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for reading double quoted strings. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00071">71</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

</div>
</div>
<a class="anchor" id="a171c7c50b1c03368cb5bcbceedc9e3ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; const <a class="el" href="class_t.html">T</a>, U &gt; *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::pair types. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00097">97</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00045">StringToValue()</a>, and <a class="el" href="benchmarkutils_8cc_source.html#l00063">value</a>.</p>

</div>
</div>
<a class="anchor" id="a381cf52f71d6735b1be93fe17a8771e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename W , typename X , bool B, template&lt; class, class, class, class, class, bool &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, X, B &gt; *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::unordered_map with a bool at the end. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00147">147</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00115">StringToStlContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="ae5b88e4b16ce819d8ee00022ec1f8616"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename W , typename X , template&lt; class, class, class, class, class &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, X &gt; *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::unordered_map without a bool at the end. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00155">155</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00115">StringToStlContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="a128a6e0d55f027c7b629c628d21ad601"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename W , bool B, template&lt; class, class, class, class, bool &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, B &gt; *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::unordered_set with a bool at the end. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00163">163</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00115">StringToStlContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="a607b871c08ef0c991b4a9519607d2b12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename W , template&lt; class, class, class, class &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W &gt; *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::map and std::unordered_set without a bool at the end. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00171">171</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00115">StringToStlContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="a90745d3418ce34d967013d54a8a318fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , template&lt; class, class, class &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a> &gt; *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::set. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00179">179</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00115">StringToStlContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="a733453960fc67677d3e232179feb197b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , template&lt; class, class &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">std::istringstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType&lt; <a class="el" href="class_t.html">T</a>, U &gt; *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for STL containers like deque, list, vector. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00186">186</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00115">StringToStlContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f54ab455c29a0e0473eae13c5da32f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ion::base::StringToValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t.html">T</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function that converts a std::string to a <a class="el" href="class_t.html">T</a>, constructing the istringstream automatically. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00194">194</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00045">StringToValue()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2d822c2dfcece498fca34403c39e41d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::TrimEndWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes any whitespace characters at the end of the string. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00146">146</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>Referenced by <a class="el" href="tracerecorder_8cc_source.html#l00105">ion::profile::TraceRecorder::AnnotateCurrentScopeAtTime()</a>, <a class="el" href="tracerecorder_8cc_source.html#l00208">ion::profile::TraceRecorder::CreateTimeStampAtTime()</a>, <a class="el" href="tracerecorder_8cc_source.html#l00160">ion::profile::TraceRecorder::EnterTimeRange()</a>, and <a class="el" href="stringutils_8h_source.html#l00155">TrimStartAndEndWhitespace()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e2d6d60c240bddbccd3182c93b54e7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::TrimStartAndEndWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes any whitespace characters at the beginning and end of the string. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00155">155</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>References <a class="el" href="stringutils_8h_source.html#l00146">TrimEndWhitespace()</a>, and <a class="el" href="stringutils_8h_source.html#l00137">TrimStartWhitespace()</a>.</p>

<p>Referenced by <a class="el" href="datetime_8cc_source.html#l00654">ion::base::DateTime::ComputeDurationString()</a>.</p>

</div>
</div>
<a class="anchor" id="a441b93d33c1fb81fbc7fbe1a82c7a454"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::TrimStartWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes any whitespace characters at the beginning of the string. </p>

<p>Definition at line <a class="el" href="stringutils_8h_source.html#l00137">137</a> of file <a class="el" href="stringutils_8h_source.html">stringutils.h</a>.</p>

<p>Referenced by <a class="el" href="stringutils_8h_source.html#l00155">TrimStartAndEndWhitespace()</a>.</p>

</div>
</div>
<a class="anchor" id="aab02d07ebfaed9b3f3f60453168b62aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API std::string ion::base::UrlDecodeString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a decoded version of a URL-encoded string. </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00222">222</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

</div>
</div>
<a class="anchor" id="adf38f316ea978c6880b2bfe123c6ad4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API std::string ion::base::UrlEncodeString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a URL-encoded version of a string. </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00246">246</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="calltracemanager_8cc_source.html#l00042">length</a>.</p>

</div>
</div>
<a class="anchor" id="a38945775ca691f4c7e2d186567037995"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ValueToString. </p>
<p>Serializes a generic value to a string. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00209">209</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>Referenced by <a class="el" href="tracerecorder_8cc_source.html#l00105">ion::profile::TraceRecorder::AnnotateCurrentScopeAtTime()</a>, <a class="el" href="vsyncprofiler_8cc_source.html#l00046">ion::profile::VSyncProfiler::RecordVSyncEvent()</a>, <a class="el" href="calltracemanager_8cc_source.html#l00386">ion::profile::CallTraceManager::SnapshotCallTraces()</a>, <a class="el" href="serialize_8h_source.html#l00263">StlContainerToString()</a>, <a class="el" href="setting_8h_source.html#l00188">ion::base::Setting&lt; bool &gt;::ToString()</a>, <a class="el" href="setting_8h_source.html#l00260">ion::base::Setting&lt; std::atomic&lt; T &gt; &gt;::ToString()</a>, and <a class="el" href="serialize_8h_source.html#l00249">ValueToString()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c71e09500e8fae9d728080e709667c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialize for bools. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00217">217</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa602b7adf7c6c9393099f30e18c0cffb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialize for printing significant digits of floating point numbers. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00225">225</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad42d941eee7dd605beb09599df28881b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00232">232</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

</div>
</div>
<a class="anchor" id="abe8153ca5be2fee5c486e8d11194be5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for writing double quoted strings. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00241">241</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="stringutils_8cc_source.html#l00105">EscapeString()</a>.</p>

</div>
</div>
<a class="anchor" id="a058c5f0c7414b7275949b4fcd0e51d3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const char *const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for writing double quoted C-strings. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00249">249</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00209">ValueToString()</a>.</p>

</div>
</div>
<a class="anchor" id="a7938ddc96c30ef3bde0a83637ebf37d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; const <a class="el" href="class_t.html">T</a>, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::pair types. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00255">255</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00209">ValueToString()</a>.</p>

</div>
</div>
<a class="anchor" id="a895e58f7de30d18c41a5cef341068a03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename W , typename X , bool B, template&lt; class, class, class, class, class, bool &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, X, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::unordered_map with a bool at the end. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00280">280</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00263">StlContainerToString()</a>.</p>

</div>
</div>
<a class="anchor" id="ab39ef8a06cde9950f3efe7a93567bf14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename W , typename X , template&lt; class, class, class, class, class &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::unordered_map without a bool at the end. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00289">289</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00263">StlContainerToString()</a>.</p>

</div>
</div>
<a class="anchor" id="abb5d36d49a044fb1b07df27099eea420"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename W , bool B, template&lt; class, class, class, class, bool &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::unordered_set with a bool at the end. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00297">297</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00263">StlContainerToString()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e3aa6da95f908ce77d015e6128d6c6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename W , template&lt; class, class, class, class &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a>, W &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::map and std::unordered_set without a bool at the end. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00305">305</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00263">StlContainerToString()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7bfe3c19d76734f325dd4c0eae22f09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , template&lt; class, class, class &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U, <a class="el" href="class_v.html">V</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for std::set. </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00313">313</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00263">StlContainerToString()</a>.</p>

</div>
</div>
<a class="anchor" id="a49af2bfa1b175239a4dfc1d65d1f0f55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , template&lt; class, class &gt; class ContainerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ion::base::ValueToString </td>
          <td>(</td>
          <td class="paramtype">const ContainerType&lt; <a class="el" href="class_t.html">T</a>, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for non-associative STL containers (deque, list, vector). </p>

<p>Definition at line <a class="el" href="serialize_8h_source.html#l00319">319</a> of file <a class="el" href="serialize_8h_source.html">serialize.h</a>.</p>

<p>References <a class="el" href="serialize_8h_source.html#l00263">StlContainerToString()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d8e4928e10d0566632ba4ce1a7352b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API std::string ion::base::WebSafeBase64Decode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes a Base64 encoded string. </p>
<p>Follows the RFC 4648 standard, accepting either base64 or base64url encoding:</p>
<ul>
<li>base64: 62 is '+', 63 is '/', and = is for padding.</li>
<li>base64url: 62 is '-', 63 is '_', and no padding is used.</li>
</ul>
<p>In this implementation, base64 is transformed to base64url before decoding the string.</p>
<p>A zero-length array is returned if the decode fails. </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00375">375</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="calltracemanager_8cc_source.html#l00042">length</a>, and <a class="el" href="benchmarkutils_8cc_source.html#l00049">str</a>.</p>

</div>
</div>
<a class="anchor" id="a7fa9facb22f72e8dfa468c0f1f59843a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API std::string ion::base::WebSafeBase64Encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes a byte array using RFC 4648 base64url ('-' and '_' for 62 and 63, respectively, and no padding). </p>
<p>The returned string will be safe for use in URLs. </p>

<p>Definition at line <a class="el" href="stringutils_8cc_source.html#l00411">411</a> of file <a class="el" href="stringutils_8cc_source.html">stringutils.cc</a>.</p>

<p>References <a class="el" href="calltracemanager_8cc_source.html#l00211">buffer</a>, and <a class="el" href="calltracemanager_8cc_source.html#l00042">length</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a4608f8e50b0898594bbef71d8a9a4ac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ION_API const <a class="el" href="classsize__t.html">size_t</a> ion::base::kInvalidIndex = static_cast&lt;<a class="el" href="classsize__t.html">size_t</a>&gt;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kInvalidIndex is a size_t value that is very unlikely to be a valid index. </p>
<p>It can be used to indicate an invalid return value from a function returning an index. </p>

<p>Definition at line <a class="el" href="invalid_8cc_source.html#l00023">23</a> of file <a class="el" href="invalid_8cc_source.html">invalid.cc</a>.</p>

<p>Referenced by <a class="el" href="attributearray_8cc_source.html#l00065">ion::gfx::AttributeArray::AddAttribute()</a>, <a class="el" href="node_8h_source.html#l00122">ion::gfx::Node::AddChild()</a>, <a class="el" href="node_8h_source.html#l00085">ion::gfx::Node::AddShape()</a>, <a class="el" href="bufferobject_8cc_source.html#l00046">ion::gfx::BufferObject::AddSpec()</a>, <a class="el" href="uniformholder_8h_source.html#l00046">ion::gfx::UniformHolder::AddUniform()</a>, <a class="el" href="gfx_2shape_8cc_source.html#l00034">ion::gfx::Shape::AddVertexRange()</a>, <a class="el" href="fontimage_8cc_source.html#l00662">ion::text::DynamicFontImage::FindContainingImageDataIndex()</a>, <a class="el" href="fontimage_8cc_source.html#l00623">ion::text::DynamicFontImage::FindImageDataIndex()</a>, <a class="el" href="array2_8h_source.html#l00071">ion::base::Array2&lt; double &gt;::Get()</a>, <a class="el" href="attributearray_8cc_source.html#l00045">ion::gfx::AttributeArray::GetAttributeIndexByName()</a>, <a class="el" href="array2_8h_source.html#l00079">ion::base::Array2&lt; double &gt;::GetMutable()</a>, <a class="el" href="tracecallextractor_8cc_source.html#l00055">ion::gfx::TraceCallExtractor::GetNthIndexOf()</a>, <a class="el" href="uniformholder_8cc_source.html#l00030">ion::gfx::UniformHolder::GetUniformIndex()</a>, <a class="el" href="uniformholder_8h_source.html#l00069">ion::gfx::UniformHolder::RemoveUniformByName()</a>, <a class="el" href="array2_8h_source.html#l00059">ion::base::Array2&lt; double &gt;::Set()</a>, <a class="el" href="uniformholder_8h_source.html#l00113">ion::gfx::UniformHolder::SetUniformByName()</a>, <a class="el" href="uniformholder_8h_source.html#l00125">ion::gfx::UniformHolder::SetUniformByNameAt()</a>, and <a class="el" href="fullallocationtracker_8cc_source.html#l00226">ion::base::FullAllocationTracker::TrackDeallocation()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceion.html">ion</a></li><li class="navelem"><a class="el" href="namespaceion_1_1base.html">base</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
